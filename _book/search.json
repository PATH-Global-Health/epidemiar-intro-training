[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EpidemiaR Introductory Materials",
    "section": "",
    "text": "Getting started\nThis book contains background material for general R basics, as well as some of the packages and functions that we will use during the EpidemiaR training lessons."
  },
  {
    "objectID": "index.html#installing-packages",
    "href": "index.html#installing-packages",
    "title": "EpidemiaR Introductory Materials",
    "section": "Installing packages",
    "text": "Installing packages\nThe training lessons will use several R packages. We will discuss these in more detail in the following sections, but it is a good idea to get everything installed and downloaded before we dive in. Note that depending on your internet connection this may take some time.\nUse this code in R to install the packages:\n# Installing packages\ninstall.packages(\n  c(\"dplyr\",\"knitr\",\"lubridate\",\"parallel\",\"readr\",\"readxl\",\"tidyr\",\"tinytex\",\n    \"tools\",\"tidyverse\",\"janitor\",\"writexl\",\"sf\",\"ISOweek\"))\nAdditional materials and resources:\n\nWIP!"
  },
  {
    "objectID": "base-r-intro.html#introduction-to-rstudio",
    "href": "base-r-intro.html#introduction-to-rstudio",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Introduction to RStudio",
    "text": "Introduction to RStudio\nR is a statistical and graphical software package, and is the very commonly used in many disciplines, including data science, statistics and the environmental and biological sciences. The great strengths of R for the research community are:\n\nIt is free, which means anyone can use it.\nIt is open source, which means you can inspect and modify the code within in.\nIt is a community, so researchers around the world have developed code for particular applications that they have made freely available. These are published as ‘packages’ which can be downloaded with just a couple of lines of code.\nBecause of all the community-developed code, there are functions available in R for pretty much every data analysis, statistical method or model, graphic or chart you could ever need. Once you understand how to use R, you will be able to access these.\nThere is an incredible amount of help to be found online for most problems (often on StackOverflow and Twitter #rstats).\n\nBy the end of this session we will have covered\n\nOpening up Rstudio\nSetting up a project in Rstudio\nExploring R, finding help, debugging and writing comments\nDifferent data types\nHow to calculate basic operations on vectors\nHow to use dataframes\nWhat packages are and how to install and use them\nHow to read in external data sources\n\nHopefully you have followed the tutorial we shared and have RStudio downloaded and installed on your computer If you open up Rstudio, you will have 3 panels that look like this\n\nThe first thing you want to do is open up a new R script\n\nYour Rstudio will now have 4 panels\n\nThese screens are:\nTop left: An “R Script” window – this is essentially a text editor where you can write code and commands to be run in the console window. You can edit and correct your work here, and save it so you can use it again. I suggest saving regularly, and keep all your successful code here so you can keep working. Try to use informative script names to help your future self, for example you could save this week’s work as “R_training_day1”.\nBottom left: This is the “R Console” – this is where the processing is done. You should typically write script code in the “R Script” window and press Ctrl+Enter (or click “Run”) to run them in the console. You may sometimes want to type directly in the console to quickly check that new object looks how you expect them to look or run simple checks that you don’t want to revisit later\nTop right: The “Environment” tab here shows all the data you’ve loaded and variables/objects you’ve created.\nBottom right: Plots you create will show here. You can also use R Help here: type a function you’re using into the search box and you will get information on its inputs (“Arguments”) and outputs (“Value”), or in the console write a ‘?’ then the function name, i.e. ‘?mean’ to understand how to use the ‘mean’ function"
  },
  {
    "objectID": "base-r-intro.html#setting-up-a-project-in-rstudio",
    "href": "base-r-intro.html#setting-up-a-project-in-rstudio",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Setting up a project in RStudio",
    "text": "Setting up a project in RStudio\nProjects are a really neat way to work in Rstudio – it means that all the inputs (i.e. data, scripts) and outputs (i.e. plots, summary tables) are stored in the same place. It also means other people can use the same project and rerun our analyses without having to define new filepaths (which can be a pain!) When starting a new project, it is a really good practice to set up a project and associated file structure\nFirstly go to file -&gt; new project, then select new directory, then new project\n\nDefine your directory (folder) name (I’d suggest something like R_training_workshop_Sept23)\nThen use the browse option to save this folder somewhere sensible for you (I tend to save things like this in a training folder on my box drive)\n\nNow you have a new project!\nThe next step is to open up a file explorer window and locate this folder\nManually create three new subfolders called data, scripts and plots – everything we use and create during this workshop will be stored here for easy reference and will be able to be reproduced by other or yourself on a different computer"
  },
  {
    "objectID": "base-r-intro.html#exploring-r-finding-help-debugging-and-writing-comments",
    "href": "base-r-intro.html#exploring-r-finding-help-debugging-and-writing-comments",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Exploring R, finding help, debugging and writing comments",
    "text": "Exploring R, finding help, debugging and writing comments\nWe can now start using R – the simplest thing to do is just to use R as a basic calculator. You can write equations in the script and run them in the console to do simple calculations\n\n20 * 10.5\n\n[1] 210\n\n17 + 23 - 7\n\n[1] 33\n\n\nThere are also a wide range of mathematical functions such as log(), sqrt(), exp()\n\nsqrt(25)\n\n[1] 5\n\n\nIf you don’t know what an inbuilt function does, type a ‘?’ before its name, and the help page will appear on the right hand side of your screen:\n\n?sqrt\n\nA note on errors – these happen ALL THE TIME! A large part of learning to code is learning how to spot and fix your errors – this is called debugging (a great hobby for malaria researchers!)\nFor example, try the following - why do they not work?\n\nsqrt(a)\nsqrt(\"a\")\nSQRT(25)\nsqrt(25))\n\nIf your code isn’t working, the first few things to check are:\n\nHave you spelled the variable names and function names correctly?\n\nDo the objects you’re working with exist in your working environment?\n\nDo you have the ‘&gt;’ appearing in the console window? If not something didn’t run properly so press Esc a few times until it reappears\n\nIf your code is still not working, please grab a trainer and we will help you debug!\nA note on commenting code - it is really good practice to comment your code - this means writing brief descriptions of what you’ve done.\nBy adding the ‘#’ before a line of code, it will not be run in your console\n\n# write in a description here so you can remember what you did in the future!\n# here I am using the formula for the area of a circle pi * r^2\narea_of_cirlce &lt;- pi * 4 ^2\n\nYou can also comment out (i.e. add a # before them) lines of code that are maybe wrong or not needed in an analysis before you decide if you need to actually delete them or not. This is good practice, because sometimes we are too hasty in deleting lines of code that we might actually need!"
  },
  {
    "objectID": "base-r-intro.html#data-types",
    "href": "base-r-intro.html#data-types",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Data types",
    "text": "Data types\nR can store and organize data, parameters, and variables of lots of different types – we will now explore a few of them. To start, we need to create a new variable with a name. The we can assign values or data to that variable using &lt;- . Here are some examples of different types of information that can be store in a variable.\n\nNumbers\nSingle numbers can be given names like this\n\nmy_first_variable &lt;- 20\nmy_first_variable\n\n[1] 20\n\n\nIt is important to think about how to name variables – do you want to be quick, or do you want your code to make sense to you and others in the future? We can use both uninformative and informative variable names\n\nb &lt;- 2/10\nmalaria_prevalence_2020 &lt;- 2/10\n\nThe “&lt;-” operator tells R to take the number to the right of the symbol and store it in the variable named on the left (You could also use”=“)\nNote: R is case sensitive so for example, the variable ‘malaria_prevalence_2020’ is different to ‘Malaria_prevalence_2020’. Variable names cannot begin with numbers, and you cannot have ‘spaces’ in your variable names (we normally use an underscore ‘_’ where we might want a space\nYou’ll probably create lots of variable names, and you might forget some of them. You can list all the ones in your session using\n\nls()\n\nOr by looking the in the ‘environment’ pane\nYou can overwrite a variable at any point, for example,\n\ntest_variable &lt;- 15\ntest_variable\n\n[1] 15\n\ntest_variable &lt;- 20\ntest_variable\n\n[1] 20\n\n\nIn R programming, the terms ‘variable’ and ‘object’ are often used interchangeably.\nNote: some variable names are not allowed - variables cannot begin with a number or punctuation. It is not a good idea to name variables after in-built R functions - i.e not a good idea to name a variable ‘sum’ or ‘mean’ - we will see very shortly that these words already have a purpose in R!\n\n\nStrings\nStrings are like numbers (in that they represent only one object), but text instead:\n\nmy_first_string  &lt;- \"avocado\"\nmy_first_string\n\n[1] \"avocado\"\n\n\nNow, try this:\n\nmy_first_string  * my_first_string\n\nWhat happens? Why? If you’re not sure what type of data your object is, you can use this function:\n\nclass(my_first_string)\n\n[1] \"character\"\n\nclass(my_first_variable)\n\n[1] \"numeric\"\n\n\nHere, “character” is the name of the datatype of strings, and “double” is a type of number. You can also use the functions “typeof” and “str” to find out about an object (try them out!).\n\n\nVectors\nVectors and lists are the same kind of object, and represent a set of variables (numbers, strings) in an order. To do this, we use the function ‘c’ which is short for ‘combine’. It combines various objects into a vector. Create these vectors in R:\n\nv1 &lt;- c(1,2,3,4,5)\nv2 &lt;- c(0.1,0.15,0.2,0.4,0.5)\nv3 &lt;- c(\"red\",\"blue\",\"green\",\"orange\",\"black\")\n\nYou can access an individual element by knowing its position in the list. So the 3rd element in the list v1 is found by using square brackets:\n\nv1[3]\n\n[1] 3\n\n\nDifferent types of brackets have different roles in R, so it’s important you use the correct type.\n\nSquare brackets - [] - are used to access elements of vectors (and dataframes and other complex structures)\nRound brackets - () - are used to contain the arguments of a function - i.e. in sqrt(25), the argument to the function ‘sqrt’ is ‘25’\n\n\n&gt; Question 1: What happens if you try to find an element that doesn't exist? (e.g. the 0th or 6th element of v1 - how do you type this and what is the output?)\n\nYou can calculate summary statistics of, and plot, a vector. What do each of these do?:\n\nmean(v1)\nsd(v1) \nvar(v1)\nmin(v1)\nmax(v1)\nsum(v1)\nsum(v1[c(1,4)])\nlength(v1)\nplot(v1)\nplot(v2,v1)\n\n\nQuestion 2: What happens if you try to do use these operations on v3 rather than v1?\n\n\nQuestion 3: Try v1* v2 - What has the operator * done to your vectors? Is that what you expected?\n\nYou can create an zero-vector of a given length (e.g. 14) like this:\n\nv4 &lt;- rep(0, 14)\n\nThis literally means - we want to repeat the value ‘0’ 14 times – you can learn more about the ‘rep’ function by typing ?rep\nYou can then add values into your vector, for example:\n\nv4[1] &lt;- 10\nv4\n\n [1] 10  0  0  0  0  0  0  0  0  0  0  0  0  0\n\n\n\nQuestion 4:What do you think the following will do?\nv4[2:14] &lt;- c(11:23) Try to guess before you try it!\n\nNote: the colon operator ‘:’ allows us to create vectors of consecutuve numbers. For example 1:5 creates a vector from 1 to 5. Quickly try creating a vector from 101 to 200."
  },
  {
    "objectID": "base-r-intro.html#data-frames",
    "href": "base-r-intro.html#data-frames",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Data frames",
    "text": "Data frames\nData frames are tables that are used for storing data, similar to what you might be used to seeing in excel. R has lots of built-in data sets that you can practice on, including one called CO2 . Type:\n\n?CO2\n\nto read the documentation. You can load this dataset into R using:\n\ndata(\"CO2\")\n\nThis will add a object call CO2 into our environment, you should be able to see it in the Environment pane. To see the data, you could type CO2 but it’s quite long. Instead you can look at the first few lines by typing\n\n head(CO2)\n\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n3   Qn1 Quebec nonchilled  250   34.8\n4   Qn1 Quebec nonchilled  350   37.2\n5   Qn1 Quebec nonchilled  500   35.3\n6   Qn1 Quebec nonchilled  675   39.2\n\n\nOr if you want to look at more lines (i.e. the first 20)\n\nhead(CO2, n = 20)\n\n   Plant   Type  Treatment conc uptake\n1    Qn1 Quebec nonchilled   95   16.0\n2    Qn1 Quebec nonchilled  175   30.4\n3    Qn1 Quebec nonchilled  250   34.8\n4    Qn1 Quebec nonchilled  350   37.2\n5    Qn1 Quebec nonchilled  500   35.3\n6    Qn1 Quebec nonchilled  675   39.2\n7    Qn1 Quebec nonchilled 1000   39.7\n8    Qn2 Quebec nonchilled   95   13.6\n9    Qn2 Quebec nonchilled  175   27.3\n10   Qn2 Quebec nonchilled  250   37.1\n11   Qn2 Quebec nonchilled  350   41.8\n12   Qn2 Quebec nonchilled  500   40.6\n13   Qn2 Quebec nonchilled  675   41.4\n14   Qn2 Quebec nonchilled 1000   44.3\n15   Qn3 Quebec nonchilled   95   16.2\n16   Qn3 Quebec nonchilled  175   32.4\n17   Qn3 Quebec nonchilled  250   40.3\n18   Qn3 Quebec nonchilled  350   42.1\n19   Qn3 Quebec nonchilled  500   42.9\n20   Qn3 Quebec nonchilled  675   43.9\n\n\nWe can see how big this dataset is using the following command\n\ndim(CO2)\n\n[1] 84  5\n\n\nWhere the first number is the number of rows and the second number is the number of columns.\n\nQ5: What are the column names of this dataset?\n\nYou can access individual element of a dataframe by knowing its row and column position. For example, “Quebec” is in third row and second column, so we can find it by typing:\n\nCO2[3,2]\n\n[1] Quebec\nLevels: Quebec Mississippi\n\n\nSo the first number refers to the row and the second number the column - we can remember this as CO2[row, column]\nYou can also extract an individual column or row. To extract the sixth row:\n\nCO2[6,]\n\n  Plant   Type  Treatment conc uptake\n6   Qn1 Quebec nonchilled  675   39.2\n\n\nor third column:\n\nCO2[,3]\n\n [1] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n [7] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[13] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[19] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[25] chilled    chilled    chilled    chilled    chilled    chilled   \n[31] chilled    chilled    chilled    chilled    chilled    chilled   \n[37] chilled    chilled    chilled    chilled    chilled    chilled   \n[43] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[49] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[55] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[61] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[67] chilled    chilled    chilled    chilled    chilled    chilled   \n[73] chilled    chilled    chilled    chilled    chilled    chilled   \n[79] chilled    chilled    chilled    chilled    chilled    chilled   \nLevels: nonchilled chilled\n\n\nYou can even subset the data, for example if you wanted to create a new dataframe, CO2_op2, which contains all rows but only the second and third columns:\n\nCO2_op2 &lt;- CO2[,2:3]\nhead(CO2_op2)\n\n    Type  Treatment\n1 Quebec nonchilled\n2 Quebec nonchilled\n3 Quebec nonchilled\n4 Quebec nonchilled\n5 Quebec nonchilled\n6 Quebec nonchilled\n\n\nYou can also check what types of data are in each column using the command\n\nstr(CO2)\n\nClasses 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':  84 obs. of  5 variables:\n $ Plant    : Ord.factor w/ 12 levels \"Qn1\"&lt;\"Qn2\"&lt;\"Qn3\"&lt;..: 1 1 1 1 1 1 1 2 2 2 ...\n $ Type     : Factor w/ 2 levels \"Quebec\",\"Mississippi\": 1 1 1 1 1 1 1 1 1 1 ...\n $ Treatment: Factor w/ 2 levels \"nonchilled\",\"chilled\": 1 1 1 1 1 1 1 1 1 1 ...\n $ conc     : num  95 175 250 350 500 675 1000 95 175 250 ...\n $ uptake   : num  16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...\n - attr(*, \"formula\")=Class 'formula'  language uptake ~ conc | Plant\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_EmptyEnv&gt; \n - attr(*, \"outer\")=Class 'formula'  language ~Treatment * Type\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_EmptyEnv&gt; \n - attr(*, \"labels\")=List of 2\n  ..$ x: chr \"Ambient carbon dioxide concentration\"\n  ..$ y: chr \"CO2 uptake rate\"\n - attr(*, \"units\")=List of 2\n  ..$ x: chr \"(uL/L)\"\n  ..$ y: chr \"(umol/m^2 s)\"\n\n\nThree of the columns are called factors – these are often strings and correspond to a column on which you may want to analyse. They typically represent a variable that has a limited number of values – for example, sex, age group, or region would be considered as factors in a malaria dataset.\nWe can see a quick summary of the numeric variables using\n\nsummary(CO2)\n\n     Plant             Type         Treatment       conc          uptake     \n Qn1    : 7   Quebec     :42   nonchilled:42   Min.   :  95   Min.   : 7.70  \n Qn2    : 7   Mississippi:42   chilled   :42   1st Qu.: 175   1st Qu.:17.90  \n Qn3    : 7                                    Median : 350   Median :28.30  \n Qc1    : 7                                    Mean   : 435   Mean   :27.21  \n Qc3    : 7                                    3rd Qu.: 675   3rd Qu.:37.12  \n Qc2    : 7                                    Max.   :1000   Max.   :45.50  \n (Other):42                                                                  \n\n\nIf we want to explore on column of a dataframe, we use the ‘$’ operator – for example\n\nCO2$Treatment\n\n [1] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n [7] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[13] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[19] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[25] chilled    chilled    chilled    chilled    chilled    chilled   \n[31] chilled    chilled    chilled    chilled    chilled    chilled   \n[37] chilled    chilled    chilled    chilled    chilled    chilled   \n[43] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[49] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[55] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[61] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[67] chilled    chilled    chilled    chilled    chilled    chilled   \n[73] chilled    chilled    chilled    chilled    chilled    chilled   \n[79] chilled    chilled    chilled    chilled    chilled    chilled   \nLevels: nonchilled chilled\n\n\nReturns just the ‘treatment’ column\nAnother useful function to quickly explore data is ‘table’ – what does this follow command return?\n\ntable(CO2$Treatment) \n\n\nnonchilled    chilled \n        42         42 \n\n\n\nQ6a: What is the value in the 14th row and 5th column?\n\n\nQ6b: What are the values in the 1st to 7th rows of the 4th column\n\n\nQ6c: How many of the samples are from Quebec?\n\nWe can also use functions to summarise the numeric data\n\nmean(CO2$uptake)\n\n[1] 27.2131\n\n\n\nQ7: What is the range and median of the uptake column?\n\nWhat if we only want to know the mean of the ‘uptake’ from Quebec?\nThis is where we’ll touch upon the fact that there are multiple ways to do almost EVERYTHING in R!\nThe traditional ‘base R’ approach uses the ‘which’ function to figure out which bits of the data we want to calculate our sum over –\n\nwhich(CO2$Type == \"Quebec\") \n\nThis returns a vector with the positions in the column CO2$Type where the type is Quebec\nThis is then used inside square brackets to select only these elements of CO2$conc\n\nCO2$conc[which(CO2$Type == \"Quebec\")]\n\n\nmean(CO2$uptake[which(CO2$Type == \"Quebec\")])\n\n[1] 33.54286\n\n\nThe tidyverse approach, which we are covering in depth tomorrow uses a function called filter\n\nop1 = filter(CO2, Type == \"Quebec\")\nmean(op1$uptake)\n\n[1] 33.54286\n\n\nWe can also filter by 2 or more criteria\n\nop2 = filter(CO2, Type == \"Quebec\", Treatment == \"chilled\")\nmean(op2$uptake)\n\n[1] 31.75238\n\n\n\nCan you now fill in this table - we want the **MEDIAN** uptake value for each treatment-type combination:"
  },
  {
    "objectID": "base-r-intro.html#packages",
    "href": "base-r-intro.html#packages",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Packages",
    "text": "Packages\nR packages are collections of functions and data sets developed by the community.\nThey increase the power of R by improving existing base R functionalities, or by adding new ones. There seems to be an R package that does almost everything – from the most widely used ones\n\ntidyverse - for data manipulation and analysis\nsf - everything spatial and map related\nggplot2 - for a wide range of plots\n\nTo the plain ridiculous:\n\nwesanderson - A library of colour pallettes based on Wes Anderson movies\ncowsay - Printed animals that say messages\n\n\nnames(wes_palettes)\n\n [1] \"BottleRocket1\"  \"BottleRocket2\"  \"Rushmore1\"      \"Rushmore\"      \n [5] \"Royal1\"         \"Royal2\"         \"Zissou1\"        \"Darjeeling1\"   \n [9] \"Darjeeling2\"    \"Chevalier1\"     \"FantasticFox1\"  \"Moonrise1\"     \n[13] \"Moonrise2\"      \"Moonrise3\"      \"Cavalcanti1\"    \"GrandBudapest1\"\n[17] \"GrandBudapest2\" \"IsleofDogs1\"    \"IsleofDogs2\"   \n\ncols = wes_palette(\"GrandBudapest1\")\ncols\n\n\n\n\n\nsay(\"My favourite R package is called purrr\", by = \"cat\")\n\n\n -------------- \nMy favourite R package is called purrr \n --------------\n    \\\n      \\\n        \\\n            |\\___/|\n          ==) ^Y^ (==\n            \\  ^  /\n             )=*=(\n            /     \\\n            |     |\n           /| | | |\\\n           \\| | |_|/\\\n      jgs  //_// ___/\n               \\_)\n  \n\n\n\nInstalling and using a package\nThere are two stages to using a package\n\nInstalling – think of this as buying a book and adding it to your library – this is an action you only ever need to do once\nLoading – think of this as taking the book from your library shelf – you need to do this each time you want to use it\n\nWe’re going to try and install and use a package called janitor (https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html)\n\ninstall.packages(“janitor”)\nlibrary(janitor)\n\nWhen installing a new package, I typically either write it in the console or comment it out in my script to avoid reinstalling every time I run my code\n\n# install.packages(“janitor”)\n\nIf you want to see all the functions available in a package, there are typically pdf’s online of each function and often user guides\nYou can also remind yourself of functions in a package by typing the package name, followed by two colon marks, for example\n\njanitor::\n\nIn your console or script\n\nQ8: Can you install and load either **wesanderson** or **cowsay** packages\n\n\nand generate either a Wes Anderson colour palette or a speaking animal?"
  },
  {
    "objectID": "base-r-intro.html#reading-in-data",
    "href": "base-r-intro.html#reading-in-data",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Reading in data",
    "text": "Reading in data\nNormally when we analyse data in R we are reading in external data sources - here we learn how to load those into R.\nYou have been sent a file called training_case_data_wide.csv - now manually save this into the data folder in your project directory\nWe can now read this into R\n\ndat &lt;- read_csv(\"data/training_case_data_wide.csv\")\n\nThis is an aggregated dataset from DHIS2 in Ethiopia - we have a row for each woreda-month between January 2018 and December 2021 (Gregorian calendar).\nIn this dataset we have a date column (period), the region, zone, and woreda, and the number of presumed and confirmed malaria cases for each woreda month:\n\npresumed - number of unconfirmed malaria cases detected at the HF\nconfirmed - number of RDT confirmed malaria cases detected at the HF\n\n\nhead(dat)\n\n# A tibble: 6 × 7\n  region zone     woreda     year period     confirmed presumed\n  &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt; &lt;date&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n1 Somali Shabelle Aba-Korow  2018 2018-01-01        NA       NA\n2 Somali Shabelle Aba-Korow  2018 2018-02-01        NA       NA\n3 Somali Shabelle Aba-Korow  2018 2018-03-01        NA       NA\n4 Somali Shabelle Aba-Korow  2018 2018-04-01        NA       NA\n5 Somali Shabelle Aba-Korow  2018 2018-05-01        NA       NA\n6 Somali Shabelle Aba-Korow  2018 2018-06-01        NA       NA\n\n\nNote that (depending on your screen size) a few variables are not visible in the console. You can remedy this with the following code:\n\noptions(dplyr.width = Inf)\n\nWe can now apply some of the tools we’ve learnt today to analyse some aggregated DHIS2 data from Ethiopia.\n\nExample: How many confirmed malaria cases there were in Ababo woreda in 2021?\n\nop1 = filter(dat, woreda == \"Ababo\", year == 2021)\nop1\n\n# A tibble: 12 × 7\n   region zone               woreda  year period     confirmed presumed\n   &lt;chr&gt;  &lt;chr&gt;              &lt;chr&gt;  &lt;dbl&gt; &lt;date&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n 1 Oromia Horo Gudru Wellega Ababo   2021 2021-01-01        79        3\n 2 Oromia Horo Gudru Wellega Ababo   2021 2021-02-01        16       12\n 3 Oromia Horo Gudru Wellega Ababo   2021 2021-03-01        13       NA\n 4 Oromia Horo Gudru Wellega Ababo   2021 2021-04-01         2       NA\n 5 Oromia Horo Gudru Wellega Ababo   2021 2021-05-01         5       NA\n 6 Oromia Horo Gudru Wellega Ababo   2021 2021-06-01         6       NA\n 7 Oromia Horo Gudru Wellega Ababo   2021 2021-07-01        14       NA\n 8 Oromia Horo Gudru Wellega Ababo   2021 2021-08-01        22       NA\n 9 Oromia Horo Gudru Wellega Ababo   2021 2021-09-01        56       NA\n10 Oromia Horo Gudru Wellega Ababo   2021 2021-10-01        70        8\n11 Oromia Horo Gudru Wellega Ababo   2021 2021-11-01        66       20\n12 Oromia Horo Gudru Wellega Ababo   2021 2021-12-01        85        6\n\nsum(op1$confirmed)\n\n[1] 434\n\n\n\nQuestion 9: What happens if we repeat this for presumed cases in Ababo in 2021?, Why?\n\nIt’s really important to look at your data closely! We can fix this problem by using the following logic:\n\ntest_vector &lt;- c(1,5,8,3,NA,6)\nsum(test_vector)\n\n[1] NA\n\nsum(test_vector, na.rm=TRUE)\n\n[1] 23\n\n\nHow did we know to do this? We looked at the help file for sum by using ?sum and saw the option to add an argument that removes NAs\n\nQuestion 9 cont.: Now we know how to remove NAs, how many presumed malaria cases were reported in Ababo woreda in 2021?\n\nWe will spend tomorrow learning about more ways to manipulate and aggregate data - but for now, if you have time left, you can try and answer these questions using the examples above!\n\nFinal exercise 1: What was the total number of cases (presumed and confirmed) in Hudet woreda in 2020?\n\n\nFinal exercise 2: Were there more presumed or confirmed cases of malaria in Awra woreda in 2020?\n\n\nFinal exercise 3: In 2021, were there more confirmed malaria cases in Hulet Ej Enese or Takusa?"
  },
  {
    "objectID": "base-r-intro.html#cheat-sheet-of-functions-weve-learnt-today",
    "href": "base-r-intro.html#cheat-sheet-of-functions-weve-learnt-today",
    "title": "Introduction to R and Rstudio and basic functions",
    "section": "Cheat sheet of functions we’ve learnt today",
    "text": "Cheat sheet of functions we’ve learnt today\n\nsqrt()\nexp()\nlog()\nrep()\nsummary()\ntable()\ndim()\nmean()\nmedian()\nrange()\nsum()\nstr()\nclass()\nhead()\nwhich()\nread.csv()\n\n(And one functions from the tidyverse world, which will be the focus of tomorrow’s session)\n\nfilter()"
  },
  {
    "objectID": "if-statements.html#basic-if-statement",
    "href": "if-statements.html#basic-if-statement",
    "title": "Using if statements",
    "section": "Basic If Statement",
    "text": "Basic If Statement\nThe basic if statement checks a condition and executes a block of code if the condition is true.\nSyntax:\nif (condition) {\n  # code to execute if the condition is true\n}\nExample:\nx &lt;- 10\n\nif (x &gt; 5) {\n  print(\"x is greater than 5\")\n}"
  },
  {
    "objectID": "if-statements.html#if-else-statement",
    "href": "if-statements.html#if-else-statement",
    "title": "Using if statements",
    "section": "If-Else Statement",
    "text": "If-Else Statement\nTo execute a block of code when the condition is false, use an else statement.\nSyntax:\nif (condition) {\n  # code to execute if the condition is true\n} else {\n  # code to execute if the condition is false\n}\nExample:\nx &lt;- 3\n\nif (x &gt; 5) {\n  print(\"x is greater than 5\")\n} else {\n  print(\"x is not greater than 5\")\n}\n\nIf-Else If-Else Statement\nFor multiple conditions, use else if to check additional conditions.\nSyntax:\nif (condition1) {\n  # code to execute if condition1 is true\n} else if (condition2) {\n  # code to execute if condition2 is true\n} else {\n  # code to execute if none of the conditions are true\n}\nExample:\nx &lt;- 7\n\nif (x &gt; 10) {\n  print(\"x is greater than 10\")\n} else if (x &gt; 5) {\n  print(\"x is greater than 5 but less than or equal to 10\")\n} else {\n  print(\"x is 5 or less\")\n}"
  },
  {
    "objectID": "if-statements.html#nested-if-statements",
    "href": "if-statements.html#nested-if-statements",
    "title": "Using if statements",
    "section": "Nested If Statements",
    "text": "Nested If Statements\nYou can also nest if statements inside one another to check multiple levels of conditions.\nExample:\nx &lt;- 15\ny &lt;- 20\n\nif (x &gt; 10) {\n  if (y &gt; 15) {\n    print(\"x is greater than 10 and y is greater than 15\")\n  } else {\n    print(\"x is greater than 10 but y is not greater than 15\")\n  }\n} else {\n  print(\"x is 10 or less\")\n}\n\nVectorized If Statements\nWhen working with vectors, ifelse is a more efficient way to apply conditional logic.\nSyntax:\nifelse(test, yes, no)\n\ntest: A logical condition.\nyes: The value to return if the condition is true.\nno: The value to return if the condition is false.\n\nExample:\nx &lt;- c(2, 7, 5, 10)\n\nresult &lt;- ifelse(x &gt; 5, \"Greater than 5\", \"5 or less\")\nprint(result)"
  },
  {
    "objectID": "if-statements.html#conclusion",
    "href": "if-statements.html#conclusion",
    "title": "Using if statements",
    "section": "Conclusion",
    "text": "Conclusion\nUsing if statements in R allows you to execute code based on conditions, making your programs more dynamic and flexible. Whether you’re using a simple if statement, adding else and else if for more complex logic, or applying conditional logic to vectors with ifelse, mastering these constructs is essential for effective programming in R."
  },
  {
    "objectID": "more-base.html#concatenating-strings-and-printing-messages",
    "href": "more-base.html#concatenating-strings-and-printing-messages",
    "title": "More base R functions",
    "section": "Concatenating strings and printing messages",
    "text": "Concatenating strings and printing messages\nIn R, paste() and paste0() are functions used to concatenate strings, while message() is used to print messages to the console. Understanding these functions helps in creating more informative and readable outputs, as well as in debugging and providing user feedback.\n\npaste() Function\nThe paste() function concatenates strings with a specified separator.\nSyntax:\npaste(..., sep = \" \", collapse = NULL)\n\n...: One or more R objects to be concatenated.\nsep: A string to separate the terms (default is a space).\ncollapse: An optional string to separate the results when concatenating vectors.\n\nExamples:\n\nConcatenating strings with spaces:\nstr1 &lt;- \"Hello\"\nstr2 &lt;- \"World\"\nresult &lt;- paste(str1, str2)\nprint(result)\n# Output: \"Hello World\"\nUsing a different separator:\nresult &lt;- paste(\"A\", \"B\", \"C\", sep = \"-\")\nprint(result)\n# Output: \"A-B-C\"\nCollapsing a vector into a single string:\nwords &lt;- c(\"apple\", \"banana\", \"cherry\")\nresult &lt;- paste(words, collapse = \", \")\nprint(result)\n# Output: \"apple, banana, cherry\"\n\n\n\npaste0() Function\nThe paste0() function is a shortcut for paste(..., sep = \"\"). It concatenates strings without any separator.\nSyntax:\npaste0(...)\n\n...: One or more R objects to be concatenated.\n\nExamples:\n\nConcatenating strings without spaces:\nstr1 &lt;- \"Hello\"\nstr2 &lt;- \"World\"\nresult &lt;- paste0(str1, str2)\nprint(result)\n# Output: \"HelloWorld\"\nConcatenating multiple strings:\nresult &lt;- paste0(\"A\", \"B\", \"C\")\nprint(result)\n# Output: \"ABC\"\n\n\n\nmessage() Function\nThe message() function is used to print a message to the console. Unlike print(), it sends its output to the standard message stream and is often used for warnings, informational messages, and debugging.\nSyntax:\nmessage(...)\n\n...: One or more R objects to be printed.\n\nExamples:\n\nPrinting a simple message:\nmessage(\"This is an informational message.\")\n# Output: This is an informational message.\nCombining paste() with message():\nname &lt;- \"John\"\nage &lt;- 30\nmessage(paste(\"Name:\", name, \"Age:\", age))\n# Output: Name: John Age: 30\nCombining paste0() with message():\nprefix &lt;- \"ID_\"\nid &lt;- 1234\nmessage(paste0(\"Generated ID: \", prefix, id))\n# Output: Generated ID: ID_1234"
  },
  {
    "objectID": "more-base.html#loading-objects-and-data-files",
    "href": "more-base.html#loading-objects-and-data-files",
    "title": "More base R functions",
    "section": "Loading objects and data files",
    "text": "Loading objects and data files\n\nR objects and data\nR provides several functions for saving and loading data, allowing you to preserve your workspace and share data with others. The save() and load() functions save and restore entire R workspaces, while saveRDS() and readRDS() handle individual R objects.\n\nsave() and load() Functions\nThe save() function saves R objects to a specified file, which can be loaded back into the R environment using the load() function.\nsave() Syntax:\nsave(..., file)\n\n...: R objects to be saved.\nfile: A character string naming the file to save the data to.\n\nload() Syntax:\nload(file)\n\nfile: A character string naming the file to load the data from.\n\nExamples:\n\nSaving multiple objects:\nx &lt;- 1:10\ny &lt;- letters[1:10]\nsave(x, y, file = \"data.RData\")\nLoading the saved objects:\nload(\"data.RData\")\nprint(x)\nprint(y)\n\n\n\nsaveRDS() and readRDS() functions\nThe saveRDS() function saves a single R object to a file, and readRDS() restores it. Unlike save(), saveRDS() does not save the object name, so you can assign it any name when you load it.\nsaveRDS() Syntax:\nsaveRDS(object, file)\n\nobject: The R object to be saved.\nfile: A character string naming the file to save the object to.\n\nreadRDS() Syntax:\nreadRDS(file)\n\nfile: A character string naming the file to read the object from.\n\nExamples:\n\nSaving a single object:\nz &lt;- matrix(1:9, nrow = 3)\nsaveRDS(z, file = \"matrix.RDS\")\nLoading the saved object:\nmy_matrix &lt;- readRDS(\"matrix.RDS\")\nprint(my_matrix)\n\nUsing load(), save(), saveRDS(), and readRDS() functions in R enables you to efficiently save and restore your data. Whether you need to save entire workspaces or individual objects, these functions provide flexible options for data persistence and sharing.\n\n\n\nCSV and Excel files"
  },
  {
    "objectID": "more-base.html#loading-csv-and-excel-files-into-r",
    "href": "more-base.html#loading-csv-and-excel-files-into-r",
    "title": "More base R functions",
    "section": "Loading CSV and Excel Files into R",
    "text": "Loading CSV and Excel Files into R\nReading data from CSV and Excel files is a common task in data analysis. R provides functions to easily load these files into your workspace for analysis.\n\nLoading CSV Files\nTo load CSV files, use the read.csv() or readr::read_csv() functions. The readr package’s read_csv() is often preferred for its speed and efficiency.\nread.csv() Syntax:\ndata &lt;- read.csv(file, header = TRUE, sep = \",\")\n\nfile: Path to the CSV file.\nheader: Logical value indicating if the file contains a header row.\nsep: Character separating the values (default is a comma).\n\nExample:\ndata &lt;- read.csv(\"path/to/yourfile.csv\")\nprint(head(data))\nreadr::read_csv() Syntax:\nlibrary(readr)\ndata &lt;- read_csv(\"path/to/yourfile.csv\")\nprint(head(data))\n\n\nLoading Excel Files\nTo load Excel files, use the readxl package, which provides the read_excel() function.\nSyntax:\nlibrary(readxl)\ndata &lt;- read_excel(path, sheet = 1)\n\npath: Path to the Excel file.\nsheet: Sheet number or name to read from (default is the first sheet).\n\nExample:\nlibrary(readxl)\ndata &lt;- read_excel(\"path/to/yourfile.xlsx\", sheet = \"Sheet1\")\nprint(head(data))\nUsing read.csv(), readr::read_csv(), and read_excel() functions, you can easily load CSV and Excel files into R for analysis. These functions provide a straightforward way to import your data and begin your analysis quickly."
  },
  {
    "objectID": "more-base.html#source-an-entire-r-script",
    "href": "more-base.html#source-an-entire-r-script",
    "title": "More base R functions",
    "section": "Source an entire R script",
    "text": "Source an entire R script\nSometimes you may want to run an entire script all at once. This can be useful when using multiple scripts that must be run in a structured order, or when storing all of your custom functions in a separate script.\nWe can use the source() function to execute an entire script at once.\nExample:\nscript_file &lt;- file.path(\"path/to/yourscript.R\")\nsource(script_file)\nThis will run all of the operations in that script in your active R sessions. All libraries, variables, and functions that are loaded or created in your sourced script will then be available in your session.\nYou can use the exists() function to create to make sure that the path you provide leads to an existing script. This function will return either TRUE or FALSE. This is also useful for checking if a data file is present in an expected location before loading and execute additional functions, especially when combined in an if statement.\nA few things to watch out for: 1. Loading libraries may cause name conflicts for functions with shared names. 2. Similarly, sourcing a script will overwrite existing variables with the same name. 3. Sourcing script may take a long time depending on the complexity of the script."
  },
  {
    "objectID": "more-base.html#additional-base-r-functions",
    "href": "more-base.html#additional-base-r-functions",
    "title": "More base R functions",
    "section": "Additional base R functions",
    "text": "Additional base R functions\nHere are some additional functions that you may encounter in during the EpidemiaR Training sections.\n\nSys.Date()/Sys.Time() will return the active data or time.\nnrow() will return the number of rows in a dataframe.\nlength() will return the number of objects in a vector, or the number of columns in a dataframe.\nunique() will return all of the unique entries in a vector."
  },
  {
    "objectID": "pipes.html#pipes-in-tidyverse",
    "href": "pipes.html#pipes-in-tidyverse",
    "title": "Chaining multiple steps using pipes",
    "section": "Pipes in tidyverse",
    "text": "Pipes in tidyverse\nTo use pipes, you’ll need to install and load the magrittr or tidyverse package. Remember that you only need to install the package one time, but you will have to load tidyverse if you want to use the pipe in a given script.\nInstall tidyverse:\ninstall.packages(\"tidyverse\")\nLoad the tidyverse package:\nlibrary(tidyverse)\n\nBasic Pipe Syntax\nThe pipe operator %&gt;% takes the output from the left-hand side and uses it as the first argument for the function on the right-hand side.\nSyntax:\ndata %&gt;% \n  function1() %&gt;%\n  function2() %&gt;%\n  function3()\n\nExample without Pipes\nConsider the following operations on a data frame without using pipes:\nExample:\nlibrary(dplyr)\n\ndata &lt;- mtcars\nfiltered_data &lt;- filter(data, cyl == 6)\nselected_data &lt;- select(filtered_data, mpg, hp)\nsummarized_data &lt;- summarize(selected_data, mean_mpg = mean(mpg), mean_hp = mean(hp))\n\nprint(summarized_data)\n\n\nExample with Pipes\nThe same operations can be performed more concisely using pipes:\nExample:\nlibrary(dplyr)\n\nmtcars %&gt;%\n  filter(cyl == 6) %&gt;%\n  select(mpg, hp) %&gt;%\n  summarize(mean_mpg = mean(mpg), mean_hp = mean(hp)) %&gt;%\n  print()\n\n\n\nUsing Pipes with Custom Functions\nPipes can also be used with custom functions. Define your function and use it within a pipe.\nExample:\ncustom_function &lt;- function(df) {\n  df %&gt;%\n    filter(gear == 4) %&gt;%\n    select(mpg, wt)\n}\n\nmtcars %&gt;%\n  custom_function() %&gt;%\n  head()\n\n\nUsing the Dot Placeholder\nSometimes, the data does not automatically fit as the first argument in the next function. In such cases, use the dot (.) as a placeholder.\nExample:\nmtcars %&gt;%\n  filter(cyl == 4) %&gt;%\n  select(mpg, wt) %&gt;%\n  {\n    n &lt;- nrow(.)\n    mean_wt &lt;- mean(.$wt)\n    data.frame(n = n, mean_wt = mean_wt)\n  }\n\n\nNesting Pipes\nPipes can be nested for more complex operations. This is particularly useful when combining multiple data frames or performing multi-step operations.\nExample:\ndata1 &lt;- mtcars %&gt;%\n  filter(cyl == 6) %&gt;%\n  select(mpg, hp)\n\ndata2 &lt;- mtcars %&gt;%\n  filter(cyl == 4) %&gt;%\n  select(mpg, wt)\n\ncombined_data &lt;- bind_rows(data1, data2)\nprint(combined_data)\nUsing pipes in R enhances code readability and efficiency, allowing you to write more concise and maintainable code. Whether performing simple data manipulations or complex data transformations, pipes streamline your workflow by reducing the need for intermediate variables and nested function calls."
  },
  {
    "objectID": "pipes.html#native-pipe-operator-in-r-r-4.1",
    "href": "pipes.html#native-pipe-operator-in-r-r-4.1",
    "title": "Chaining multiple steps using pipes",
    "section": "Native Pipe Operator in R (R 4.1+)",
    "text": "Native Pipe Operator in R (R 4.1+)\nStarting with R version 4.1, a native pipe operator (|&gt;) was introduced, providing an alternative to the %&gt;% pipe from the magrittr package. The native pipe is part of the base R language, eliminating the need to load external packages for basic piping operations.\n\nBasic Syntax\nThe native pipe operator works similarly to the %&gt;% operator but uses |&gt; instead.\nSyntax:\ndata |&gt; \n  function1() |&gt;\n  function2() |&gt;\n  function3()\nHere is an example using traditional function chaining without the native pipe:\nExample:\ndata &lt;- mtcars\nfiltered_data &lt;- filter(data, cyl == 6)\nselected_data &lt;- select(filtered_data, mpg, hp)\nsummarized_data &lt;- summarize(selected_data, mean_mpg = mean(mpg), mean_hp = mean(hp))\n\nprint(summarized_data)\nThe same operations can be performed more concisely using the native pipe:\nExample:\nmtcars |&gt;\n  (\\(df) filter(df, cyl == 6))() |&gt;\n  (\\(df) select(df, mpg, hp))() |&gt;\n  (\\(df) summarize(df, mean_mpg = mean(mpg), mean_hp = mean(hp)))() |&gt;\n  print()\n\n\nUsing Native Pipe with Custom Functions\nNative pipes can also be used with custom functions, providing a clean and readable way to chain operations.\nExample:\ncustom_function &lt;- function(df) {\n  df |&gt;\n    filter(gear == 4) |&gt;\n    select(mpg, wt)\n}\n\nmtcars |&gt;\n  custom_function() |&gt;\n  head()\n\n\nUsing the Dot Placeholder\nWhile the native pipe does not use the dot (.) placeholder in the same way as %&gt;%, it can still be used flexibly with anonymous functions.\nExample:\nmtcars |&gt;\n  (\\(df) filter(df, cyl == 4))() |&gt;\n  (\\(df) select(df, mpg, wt))() |&gt;\n  (\\(df) {\n    n &lt;- nrow(df)\n    mean_wt &lt;- mean(df$wt)\n    data.frame(n = n, mean_wt = mean_wt)\n  })()\nThe introduction of the native pipe operator in R 4.1 provides a built-in and efficient way to chain operations, enhancing code readability without relying on external packages. While it lacks some of the tools of %&gt;%, such as the dot placeholder, it integrates seamlessly with base R functions and custom workflows.\nYou may encounter both types of pipes, and most often they work interchangeably. However, it is important to note the stuble differences between the tidyverse and native pipes, especially when debugging errors."
  },
  {
    "objectID": "dpylr-tidyr-intro.html#the-power-of-packages",
    "href": "dpylr-tidyr-intro.html#the-power-of-packages",
    "title": "Data manipulation with *dplyr* and *tidyr*",
    "section": "The power of packages",
    "text": "The power of packages\nOne of the great things about using R are the thousands of available packages, which provide additional functions for many analytical tasks, such as data cleaning, statistical modelling, mapping, and much more. R packages are open-source, which means that they are free to use and maintained by the R community.\n\nInstalling and loading packages\nThroughout the rest of the workshop we will use a set of R packages manipulating data and creating plots and maps. As we covered in the Day 1 lesson, we first need to install the package on our computer using the install.packages() function. This only needs to be done one time (you probably already did this earlier).\n\ninstall.packages(\"dplyr\")\n\nOnce the package has been installed, we can load it into our current R session using the library() function. Unlike installing, you will need to load the library each time you want to use it. This is because some libraries may have functions with the same names as other libraries or as our variables.\n\nlibrary(dplyr) \n\nFor the next series of exercises, we will be using a group of packages which have been designed to work together to do common data science tasks. This group of packages is called the “Tidyverse”, because it is designed to work within the “tidy” data philosophy:\n\n\nSome important qualities of this philosophy is that our data should have the following format:\n\nEach column should be a single variable with one data type.\nEach row should be a single observation.\nEach cell should be a single value contains one piece of information.\n\nWe can install all of these packages at once using install.package(\"tidyverse\"). Remember that we only install the package once, so it is actually better to type this directly into the console instead of in our R script since it does not need to be repeated. Also be aware that this may take some time especially if internet quality is poor. After the package has finished installing it is ready to be loaded into our R session.\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#reading-data-into-r",
    "href": "dpylr-tidyr-intro.html#reading-data-into-r",
    "title": "Data manipulation with *dplyr* and *tidyr*",
    "section": "Reading data into R",
    "text": "Reading data into R\nOnce the tidyverse package is loaded into our session we will have access to all of the functions in each of the Tidyverse packages. This includes packages for loading, manipulating, and plotting data. The function we will use is read_csv() to read in the woreda-level data we worked with previously. Note that this is similar but slightly different to the read.csv() function we used in our previous exercise.\n\ncase_data &lt;- read_csv(\"data/training_case_data_long.csv\")\n\nThis is the same dataset we used in the Day 1 workshop, only this time we called the object case_data instead of dat. It’s good practice to name your objects something short and meaningful, so that it’s easy to type and remember (this is especially useful when you have multiple data objects).\nAlso, in this file the data are organized in “long” format, whereas the file used in Day 1 was in “wide” format. We will discuss the difference between “long” and “wide” formatted data in today’s material, as well as how to change the shape of our data.\n\nInspecting data\nLike in the previous exercise, we can use the head() and summary() functions to view aspects of the dataframe. We can also use the view() function to open the entire file in the R Studio Viewer, however view large files (millions of rows) can cause R Studio to crash. We can also install additional packages, such as skimr to get an even more detailed summary (run install.package(\"skimr\") in your console).\n\nhead(case_data)\nstr(case_data)\nsummary(case_data)\n\n# Using skimr package, remember to install first!\nlibrary(skimr)\nskim(case_data)\n\n\n\n\nQuestion 1: How many rows and columns are in case_data?\n\n\nQuestion 2: What “type” of data are each column (character, vector, etc.)?"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#data-manipulation-using-tidyverse",
    "href": "dpylr-tidyr-intro.html#data-manipulation-using-tidyverse",
    "title": "Data manipulation with *dplyr* and *tidyr*",
    "section": "Data manipulation using *tidyverse*",
    "text": "Data manipulation using *tidyverse*\nIn the Day 1 workshop we learned some built-in functions, or “base” functions, for simple data manipulations such as selecting a specific column or filter for only rows that match some criteria. In this lesson we will learn the *tidyverse* approach to these and additional common data manipulation tasks, using two packages called *dplyr* and *tidyr*. The *dplyr* package provides functions for the most common data manipulations jobs, and the *tidyr*package provides functions for reshaping or pivoting dataframes (similar to pivot tables in Microsoft Excel).\n\nSelecting columns and filtering rows\nTo select a specific column from a dataframe, use the select() function. The first argument will always be the dataframe object that you’re working with, followed by the name(s) of the column or columns you want to select.\n\n# Select just one column (region)\nselect(case_data, region)\n# Select multiple columns\nselect(case_data, woreda, data_type, count)\n\nTo select all the columns except certain ones, you can use a - in front of the column name.\n\n# Select all but one column\nselect(case_data, -region)\n# Removing multiple columns\nselect(case_data, -period, -region)\n\nTo choose specific rows based on some criteria, use filter(). Again, the first argument will be the dataframe, then the following argument will be the condition that we want use to subset the data.\n\nfilter(case_data, region == \"Oromia\")\n\n# A tibble: 32,064 × 7\n   region zone               woreda  year period     data_type count\n   &lt;chr&gt;  &lt;chr&gt;              &lt;chr&gt;  &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n 1 Oromia Horo Gudru Wellega Ababo   2018 2018-01-01 confirmed    NA\n 2 Oromia Horo Gudru Wellega Ababo   2018 2018-02-01 confirmed    NA\n 3 Oromia Horo Gudru Wellega Ababo   2018 2018-03-01 confirmed    NA\n 4 Oromia Horo Gudru Wellega Ababo   2018 2018-04-01 confirmed    NA\n 5 Oromia Horo Gudru Wellega Ababo   2018 2018-05-01 confirmed    NA\n 6 Oromia Horo Gudru Wellega Ababo   2018 2018-06-01 confirmed    NA\n 7 Oromia Horo Gudru Wellega Ababo   2018 2018-07-01 confirmed    16\n 8 Oromia Horo Gudru Wellega Ababo   2018 2018-08-01 confirmed    83\n 9 Oromia Horo Gudru Wellega Ababo   2018 2018-09-01 confirmed    35\n10 Oromia Horo Gudru Wellega Ababo   2018 2018-10-01 confirmed   167\n# ℹ 32,054 more rows\n\n\nNotice here that just like in Day 1 use have to use a == sign for setting a condition. You can read this as saying, “choose the rows in case_data where region is equal to”Oromia”. Also notice that the number of rows in the object has gone down from 94176 to 32064.\nWe can filter on multiple conditions at once using multiple arguments, using a , to state separate conditions.\n\nfilter(case_data, region == \"Oromia\", data_type == \"presumed\")\n\n# A tibble: 16,032 × 7\n   region zone               woreda  year period     data_type count\n   &lt;chr&gt;  &lt;chr&gt;              &lt;chr&gt;  &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n 1 Oromia Horo Gudru Wellega Ababo   2018 2018-01-01 presumed     NA\n 2 Oromia Horo Gudru Wellega Ababo   2018 2018-02-01 presumed     NA\n 3 Oromia Horo Gudru Wellega Ababo   2018 2018-03-01 presumed     NA\n 4 Oromia Horo Gudru Wellega Ababo   2018 2018-04-01 presumed     NA\n 5 Oromia Horo Gudru Wellega Ababo   2018 2018-05-01 presumed     NA\n 6 Oromia Horo Gudru Wellega Ababo   2018 2018-06-01 presumed     NA\n 7 Oromia Horo Gudru Wellega Ababo   2018 2018-07-01 presumed     NA\n 8 Oromia Horo Gudru Wellega Ababo   2018 2018-08-01 presumed     NA\n 9 Oromia Horo Gudru Wellega Ababo   2018 2018-09-01 presumed     NA\n10 Oromia Horo Gudru Wellega Ababo   2018 2018-10-01 presumed     NA\n# ℹ 16,022 more rows\n\n\nBy default, each of the conditions in filter() must be TRUE to remain in the subset, however there are special operators that allow for more complex conditional operations. The most common are the AND (&) and OR (|) operators. Here are some examples:\n\n# region is Easter AND data type is presumed \nfilter(case_data, region == \"Oromia\" & data_type == \"presumed\")\n\n# region is Oromia OR data type is presumed \nfilter(case_data, region == \"Oromia\" | data_type == \"presumed\")\n\n# region is Afar OR Oromia, AND count is over 1,000\nfilter(case_data, region == \"Afar\" | region == \"Oromia\", count &gt; 1000)\n\n\n\nQuestion 3: Why did we not use & in the third example?\n\nAnother useful operator is the MATCH operator (%in%), which will return TRUE if a value matches any value in a list of possible options.\n\n# Keep rows where data type could be presumed or confirmed\nfilter(case_data, data_type %in% c(\"presumed\", \"confirmed\"))\n\n# A tibble: 94,176 × 7\n   region zone     woreda     year period     data_type count\n   &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n 1 Somali Shabelle Aba-Korow  2018 2018-01-01 confirmed    NA\n 2 Somali Shabelle Aba-Korow  2018 2018-02-01 confirmed    NA\n 3 Somali Shabelle Aba-Korow  2018 2018-03-01 confirmed    NA\n 4 Somali Shabelle Aba-Korow  2018 2018-04-01 confirmed    NA\n 5 Somali Shabelle Aba-Korow  2018 2018-05-01 confirmed    NA\n 6 Somali Shabelle Aba-Korow  2018 2018-06-01 confirmed    NA\n 7 Somali Shabelle Aba-Korow  2018 2018-07-01 confirmed    21\n 8 Somali Shabelle Aba-Korow  2018 2018-08-01 confirmed    13\n 9 Somali Shabelle Aba-Korow  2018 2018-09-01 confirmed    37\n10 Somali Shabelle Aba-Korow  2018 2018-10-01 confirmed    20\n# ℹ 94,166 more rows\n\n# Keep rows from a group of selected woredas\nstudy_woredas &lt;- c(\"Adama Town\", \"Liban Jawi\", \"Mieso\", \"Wondo\")\nfilter(case_data, woreda %in% study_woredas)\n\n# A tibble: 384 × 7\n   region zone       woreda      year period     data_type count\n   &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;      &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n 1 Oromia East Shewa Adama Town  2018 2018-01-01 confirmed    NA\n 2 Oromia East Shewa Adama Town  2018 2018-02-01 confirmed    NA\n 3 Oromia East Shewa Adama Town  2018 2018-03-01 confirmed    NA\n 4 Oromia East Shewa Adama Town  2018 2018-04-01 confirmed    NA\n 5 Oromia East Shewa Adama Town  2018 2018-05-01 confirmed    NA\n 6 Oromia East Shewa Adama Town  2018 2018-06-01 confirmed    NA\n 7 Oromia East Shewa Adama Town  2018 2018-07-01 confirmed    NA\n 8 Oromia East Shewa Adama Town  2018 2018-08-01 confirmed    NA\n 9 Oromia East Shewa Adama Town  2018 2018-09-01 confirmed    NA\n10 Oromia East Shewa Adama Town  2018 2018-10-01 confirmed    NA\n# ℹ 374 more rows\n\n\n\nQuestion 4: Can you show all of the “presumed” data in the Somali region?\n\n\nQuestion 5: Can you show all “confirmed” that have a count over 2000?\n\nFinally, the ! operator in R used for NOT or opposite conditions. The most common use cases are for using NOT EQUAL (!=) or does NOT MATCH operations.\n\n# Keep all rows where region is NOT oromia\nfilter(case_data, region != \"Addis Ababa\")\n\n# A tibble: 93,216 × 7\n   region zone     woreda     year period     data_type count\n   &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n 1 Somali Shabelle Aba-Korow  2018 2018-01-01 confirmed    NA\n 2 Somali Shabelle Aba-Korow  2018 2018-02-01 confirmed    NA\n 3 Somali Shabelle Aba-Korow  2018 2018-03-01 confirmed    NA\n 4 Somali Shabelle Aba-Korow  2018 2018-04-01 confirmed    NA\n 5 Somali Shabelle Aba-Korow  2018 2018-05-01 confirmed    NA\n 6 Somali Shabelle Aba-Korow  2018 2018-06-01 confirmed    NA\n 7 Somali Shabelle Aba-Korow  2018 2018-07-01 confirmed    21\n 8 Somali Shabelle Aba-Korow  2018 2018-08-01 confirmed    13\n 9 Somali Shabelle Aba-Korow  2018 2018-09-01 confirmed    37\n10 Somali Shabelle Aba-Korow  2018 2018-10-01 confirmed    20\n# ℹ 93,206 more rows\n\n\nNote that for NOT EQUAL the ! operator comes next to the = sign, but for the NOT MATCH condition the ! comes before the condition state. In the second case you can read that as, “do the opposite of this condition”.\n\nQuestion 6a: Create a table for all confirmed malaria cases in Amhara and Harari regions in 2020.\n\n\nQuestion 6b: Create a table for all presumed malaria cases NOT in Amhara and Harari regions in 2020.\n\n\nQuestion 7a: Create a table for all presumed and confirmed cases that are over 500.\n\n\nQuestion 7b: Create a table for all data that are NOT presumed and that are over 500.\n\nThe types of conditional states that you can use depends on the type of column you want to base your filter()on. For example, filter(case_data, count &gt; 1000) makes sense since the count column contains numeric data. However, filter(case_data, region &gt; 1000) doesn’t make sense since the region column contains character data. The rule of thumb is that the value you use to set your condition should match the “type” of data in selected column.\nIn the next section, we see how to deal with a special case:\n\n\nWorking with dates using the *lubridate* package\nIn the “tidy” data approach to working with data each column is a specific type of data, each row is an observation, and each cell is an individual value which conveys a single piece of information. Our dataset matches this philosophy, except for the “period” values, which contain information on the year, month, and day of the observation.\nWe could create separate columns for the year, month, and day, but this may complicate our filtering. For instance, what happens if we want to filter for a study period that continues across over parts of adjacent months or year? Such a common task would require complex set of conditional statements to filter correctly.\nThe *lubridate* package provides a number of functions to make working with data much easier. This is not included in *tidyverse*, so we have to install and then load it into our session.\n\n# install.packages(lubridate)\nlibrary(lubridate)\n\nThe ymd() function allows us to create a Date class object based on the string input for YEAR-MONTH-DAY:\n\n# Vector of workshop days\nworkshop_days &lt;- c(\"2023-09-04\", \"2023-09-05\", \"2023-09-06\", \"2023-09-07\",\"2023-09-08\")\nclass(workshop_days)\n\n[1] \"character\"\n\n# Convert to a Date class\nworkshop_days &lt;- ymd(workshop_days)\nclass(workshop_days)\n\n[1] \"Date\"\n\n\nOnce you have a Date class object, *lubridate* provides many, many functions for working with date information. The primary functions we will use in this workshop are year() and month(), but there are many more in this *lubridate* cheatsheet.\n\nyear(workshop_days)\n\n[1] 2023 2023 2023 2023 2023\n\nmonth(workshop_days)\n\n[1] 9 9 9 9 9\n\nmonth(workshop_days, label = TRUE)\n\n[1] Sep Sep Sep Sep Sep\n12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec\n\n\nThese functions can be used in filter().\n\nfilter(case_data, year(period) == 2020)\n\n# A tibble: 23,544 × 7\n   region zone     woreda     year period     data_type count\n   &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n 1 Somali Shabelle Aba-Korow  2020 2020-01-01 confirmed    NA\n 2 Somali Shabelle Aba-Korow  2020 2020-02-01 confirmed    NA\n 3 Somali Shabelle Aba-Korow  2020 2020-03-01 confirmed    NA\n 4 Somali Shabelle Aba-Korow  2020 2020-04-01 confirmed    NA\n 5 Somali Shabelle Aba-Korow  2020 2020-05-01 confirmed    NA\n 6 Somali Shabelle Aba-Korow  2020 2020-06-01 confirmed    NA\n 7 Somali Shabelle Aba-Korow  2020 2020-07-01 confirmed    NA\n 8 Somali Shabelle Aba-Korow  2020 2020-08-01 confirmed    NA\n 9 Somali Shabelle Aba-Korow  2020 2020-09-01 confirmed    15\n10 Somali Shabelle Aba-Korow  2020 2020-10-01 confirmed    NA\n# ℹ 23,534 more rows\n\nfilter(case_data, between(period, ymd(\"2019-01-01\"), ymd(\"2019-06-30\")))\n\n# A tibble: 11,772 × 7\n   region zone                 woreda     year period     data_type count\n   &lt;chr&gt;  &lt;chr&gt;                &lt;chr&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n 1 Somali Shabelle             Aba-Korow  2019 2019-01-01 confirmed    NA\n 2 Somali Shabelle             Aba-Korow  2019 2019-02-01 confirmed    NA\n 3 Somali Shabelle             Aba-Korow  2019 2019-03-01 confirmed    NA\n 4 Somali Shabelle             Aba-Korow  2019 2019-04-01 confirmed    NA\n 5 Somali Shabelle             Aba-Korow  2019 2019-05-01 confirmed    NA\n 6 Somali Shabelle             Aba-Korow  2019 2019-06-01 confirmed    NA\n 7 Afar   Zone 2 (Kilbet Rasu) Aba 'Ala   2019 2019-01-01 confirmed    55\n 8 Afar   Zone 2 (Kilbet Rasu) Aba 'Ala   2019 2019-02-01 confirmed    26\n 9 Afar   Zone 2 (Kilbet Rasu) Aba 'Ala   2019 2019-03-01 confirmed     9\n10 Afar   Zone 2 (Kilbet Rasu) Aba 'Ala   2019 2019-04-01 confirmed    25\n# ℹ 11,762 more rows\n\n\n\n\n\n\n\nQuestion 8: What were the reported total cases (presumed and confirmed) in Bambasi woreda each month during 2018?\n\n\nQuestion 9: How many cases (presumed and confirmed) were reported in April 2020 in Gudetu Kondole woreda?\n\n\nQuestion 10 (HARD): What were the monthly confirmed cases in Bambasi during the peak transmission season (~September-December) each year?\n\n\n\nCreating new columns with mutate()\nAnother common task is creating new columns based on values in existing columns. The *dplyr* function for this action is mutate().\nHere is an example using the *lubridate* function from the section above to make a column for the month of observation:\n\nmutate(case_data, month = month(period))\n\n# A tibble: 94,176 × 8\n   region zone     woreda     year period     data_type count month\n   &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;\n 1 Somali Shabelle Aba-Korow  2018 2018-01-01 confirmed    NA     1\n 2 Somali Shabelle Aba-Korow  2018 2018-02-01 confirmed    NA     2\n 3 Somali Shabelle Aba-Korow  2018 2018-03-01 confirmed    NA     3\n 4 Somali Shabelle Aba-Korow  2018 2018-04-01 confirmed    NA     4\n 5 Somali Shabelle Aba-Korow  2018 2018-05-01 confirmed    NA     5\n 6 Somali Shabelle Aba-Korow  2018 2018-06-01 confirmed    NA     6\n 7 Somali Shabelle Aba-Korow  2018 2018-07-01 confirmed    21     7\n 8 Somali Shabelle Aba-Korow  2018 2018-08-01 confirmed    13     8\n 9 Somali Shabelle Aba-Korow  2018 2018-09-01 confirmed    37     9\n10 Somali Shabelle Aba-Korow  2018 2018-10-01 confirmed    20    10\n# ℹ 94,166 more rows\n\n\nFirst, state the name for the new column, then = followed by the function for the new value. You can create multiple new columns in a single mutate() call, using a , to separate each column.\n\nmutate(case_data,\n    month_num = month(period),\n    month_name = month(period, label = TRUE))\n\n# A tibble: 94,176 × 9\n   region zone     woreda   year period     data_type count month_num month_name\n   &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;ord&gt;     \n 1 Somali Shabelle Aba-Ko…  2018 2018-01-01 confirmed    NA         1 Jan       \n 2 Somali Shabelle Aba-Ko…  2018 2018-02-01 confirmed    NA         2 Feb       \n 3 Somali Shabelle Aba-Ko…  2018 2018-03-01 confirmed    NA         3 Mar       \n 4 Somali Shabelle Aba-Ko…  2018 2018-04-01 confirmed    NA         4 Apr       \n 5 Somali Shabelle Aba-Ko…  2018 2018-05-01 confirmed    NA         5 May       \n 6 Somali Shabelle Aba-Ko…  2018 2018-06-01 confirmed    NA         6 Jun       \n 7 Somali Shabelle Aba-Ko…  2018 2018-07-01 confirmed    21         7 Jul       \n 8 Somali Shabelle Aba-Ko…  2018 2018-08-01 confirmed    13         8 Aug       \n 9 Somali Shabelle Aba-Ko…  2018 2018-09-01 confirmed    37         9 Sep       \n10 Somali Shabelle Aba-Ko…  2018 2018-10-01 confirmed    20        10 Oct       \n# ℹ 94,166 more rows\n\n\nRemember that if you want to save any changes you will have to save the output into an object using the &lt;- assignment operator. Otherwise then will not be updated in your variable.\n\ncase_data_dates &lt;- mutate(case_data,\n    month_num = month(period),\n    month_name = month(period, label = TRUE))\n\nIn later sections we will see how to use mutate() to make calculations.\n\nQuestion 11: Can you add a new variable (column) to the dataset that gives the quarter of the year?\n\n\nQuestion 12: Can you add a new variable (column) to the dataset that gives just the last 2 digits of the year? i.e. 2021 becomes 21"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#use-pipes-to-combine-steps",
    "href": "dpylr-tidyr-intro.html#use-pipes-to-combine-steps",
    "title": "Data manipulation with *dplyr* and *tidyr*",
    "section": "Use Pipes to combine steps",
    "text": "Use Pipes to combine steps\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nFor intermediate steps, we need to create a new intermediate object for the output of our first function, which will then be used as an input for the second function:\n\ncase_data_oromia_confirmed &lt;- filter(case_data, region == \"Oromia\", data_type == \"confirmed\")\ncase_data_oromia_woreda_months &lt;- select(case_data_oromia_confirmed, woreda, period, count)\ncase_data_oromia_woreda_months\n\n# A tibble: 16,032 × 3\n   woreda period     count\n   &lt;chr&gt;  &lt;date&gt;     &lt;dbl&gt;\n 1 Ababo  2018-01-01    NA\n 2 Ababo  2018-02-01    NA\n 3 Ababo  2018-03-01    NA\n 4 Ababo  2018-04-01    NA\n 5 Ababo  2018-05-01    NA\n 6 Ababo  2018-06-01    NA\n 7 Ababo  2018-07-01    16\n 8 Ababo  2018-08-01    83\n 9 Ababo  2018-09-01    35\n10 Ababo  2018-10-01   167\n# ℹ 16,022 more rows\n\n\nThis approach is readable, but it can quickly clutter up your workspace and take up additional memory. And if you’re trying to use meaningful object names it can get tedious quickly.\nYou can also nest the functions (one function inside of the another).\n\ncase_data_oromia_woreda_months &lt;- select(\n  filter(case_data, region == \"Oromia\", data_type == \"confirmed\"), \n  woreda, period, count)\n\nThis doesn’t clutter the workshop or take up unnecessary memory, but it is difficult to read especially since R will interpret these steps from the inside out (first filter, then select).\nThe last option is to use pipes, a new addition to R. A pipe lets you take the output from one function and input it directly into the next function. By default, this will automatically go into the first argument of the new function. This is useful for stringing together multiple data cleaning steps while maintaining readability and keeping our environment clear. The *tidyverse* package includes a pipe function which looks like %&gt;%. In RStudio, the shortcut for this pipe is Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac. You can adjust this shortcut under Tools &gt;&gt; Modify Keyboard Shortcuts…\nHere’s an example of using a pipe for combine the filter and select from the previous example.\n\ncase_data %&gt;% \n  filter(region == \"Oromia\", data_type == \"confirmed\") %&gt;% \n  select(woreda, period, count)\n\n# A tibble: 16,032 × 3\n   woreda period     count\n   &lt;chr&gt;  &lt;date&gt;     &lt;dbl&gt;\n 1 Ababo  2018-01-01    NA\n 2 Ababo  2018-02-01    NA\n 3 Ababo  2018-03-01    NA\n 4 Ababo  2018-04-01    NA\n 5 Ababo  2018-05-01    NA\n 6 Ababo  2018-06-01    NA\n 7 Ababo  2018-07-01    16\n 8 Ababo  2018-08-01    83\n 9 Ababo  2018-09-01    35\n10 Ababo  2018-10-01   167\n# ℹ 16,022 more rows\n\n\nIn this code, we used a pipe to send case_data into a filter() function and keep the rows for confirmed cases in Oromia region, then used another pipe to send that output into a select() where we only kept the woreda, period, and count columns. We didn’t need to explicitly state the data object in the filter and select because data is always the first argument.\nYou may find it helpful to read the pipe like the word “then”. Take the case, then filter for Oromia region and confirmed cases, then select the woredas, periods, and counts. We can also save this into a new object.\n\noromia_confirmed_cases &lt;- case_data %&gt;% \n  filter(region == \"Oromia\", data_type == \"confirmed\") %&gt;% \n  select(woreda, period, count)\n\n\n\n\n\nQuestion 13: Using pipes, create a table contain the confirmed cases in January 2019 for each woreda in Oromia region. The table should only have two columns (woreda and count)\n\n\nGrouping and summarizing data\nAnother common data manipulation task involves grouping data together and applying summary functions such as calculating means or totals. We can do some of these types of operations already. For instance, we can get the total number of presumed cases in Oromia region.\n\noromia_presumed &lt;- case_data %&gt;% \n  filter(data_type == \"presumed\", region == \"Oromia\")\nsum(oromia_presumed$count, na.rm = T)\n\n[1] 58132\n\n\nBut what if we want to get summaries for each region at once? We could repeat the steps above, separating each region, calculating the totals, and then grouping these summaries back together. In programming this concept is often referred to as the split-apply-combine paradigm. The key *dplyr* functions for these tasks are group_by() and summarize() (you can also use the “proper” summarise() spelling as well).\nFirst, group_by() takes in a column that contains categorical data, then use summarize() to calculate new summary statistics.\n\ncase_data %&gt;% \n  filter(data_type == \"presumed\") %&gt;% \n  group_by(region) %&gt;% \n  summarise(mean_presumed = mean(count, na.rm = TRUE))\n\n# A tibble: 11 × 2\n   region           mean_presumed\n   &lt;chr&gt;                    &lt;dbl&gt;\n 1 Addis Ababa              13.2 \n 2 Afar                     52.2 \n 3 Amhara                   24.9 \n 4 Benishangul Gumz         45.5 \n 5 Dire Dawa                 6.54\n 6 Gambela                  70.3 \n 7 Harari                   12.2 \n 8 Oromia                   16.9 \n 9 SNNP                     29.6 \n10 Somali                   54.8 \n11 Tigray                   56.6 \n\n\nYou can also group by more than one column, and output multiple columns within a single summarize() call.\n\ncase_data %&gt;% \n  filter(data_type == \"presumed\") %&gt;% \n  group_by(region, woreda, year) %&gt;% \n  summarise(mean_presumed_per_month = mean(count, na.rm = TRUE), \n            total_presumed_per_month = sum(count, na.rm = TRUE))\n\n# A tibble: 3,924 × 5\n# Groups:   region, woreda [981]\n   region      woreda         year mean_presumed_per_mo…¹ total_presumed_per_m…²\n   &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt;                  &lt;dbl&gt;                  &lt;dbl&gt;\n 1 Addis Ababa Addis Ketema   2018                  19.3                     212\n 2 Addis Ababa Addis Ketema   2019                  66.6                     666\n 3 Addis Ababa Addis Ketema   2020                  15.8                     158\n 4 Addis Ababa Addis Ketema   2021                   2.67                     24\n 5 Addis Ababa Akaki - Kalit  2018                  24.7                     272\n 6 Addis Ababa Akaki - Kalit  2019                  66.3                     729\n 7 Addis Ababa Akaki - Kalit  2020                  30.1                     331\n 8 Addis Ababa Akaki - Kalit  2021                  27.8                     278\n 9 Addis Ababa Arada          2018                   1.75                     14\n10 Addis Ababa Arada          2019                   2.14                     15\n# ℹ 3,914 more rows\n# ℹ abbreviated names: ¹​mean_presumed_per_month, ²​total_presumed_per_month\n\n\n\ncase_data %&gt;% \n  filter(data_type == \"presumed\") %&gt;% \n  group_by(region, woreda, year) %&gt;% \n  summarise(mean_presumed_per_month = mean(count, na.rm = TRUE), \n            total_presumed_per_month = sum(count, na.rm = TRUE))\n\n# A tibble: 3,924 × 5\n# Groups:   region, woreda [981]\n   region      woreda         year mean_presumed_per_mo…¹ total_presumed_per_m…²\n   &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt;                  &lt;dbl&gt;                  &lt;dbl&gt;\n 1 Addis Ababa Addis Ketema   2018                  19.3                     212\n 2 Addis Ababa Addis Ketema   2019                  66.6                     666\n 3 Addis Ababa Addis Ketema   2020                  15.8                     158\n 4 Addis Ababa Addis Ketema   2021                   2.67                     24\n 5 Addis Ababa Akaki - Kalit  2018                  24.7                     272\n 6 Addis Ababa Akaki - Kalit  2019                  66.3                     729\n 7 Addis Ababa Akaki - Kalit  2020                  30.1                     331\n 8 Addis Ababa Akaki - Kalit  2021                  27.8                     278\n 9 Addis Ababa Arada          2018                   1.75                     14\n10 Addis Ababa Arada          2019                   2.14                     15\n# ℹ 3,914 more rows\n# ℹ abbreviated names: ¹​mean_presumed_per_month, ²​total_presumed_per_month\n\n\nSometimes it is useful to rearrange the result of our summarized dataset, in which case we can use the arrange() function.\n\ncase_data %&gt;% \n  filter(data_type == \"presumed\", \n         year(period) == 2019) %&gt;% \n  group_by(woreda, period) %&gt;% \n  summarise(total_presumed_per_month = sum(count)) %&gt;% \n  arrange(total_presumed_per_month)\n\n# A tibble: 11,760 × 3\n# Groups:   woreda [980]\n   woreda       period     total_presumed_per_month\n   &lt;chr&gt;        &lt;date&gt;                        &lt;dbl&gt;\n 1 Ada'a        2019-10-01                        1\n 2 Ada'a        2019-11-01                        1\n 3 Addi Arekay  2019-09-01                        1\n 4 Addis Ketema 2019-09-01                        1\n 5 Adhaki       2019-10-01                        1\n 6 Adigrat Town 2019-01-01                        1\n 7 Adola Town   2019-04-01                        1\n 8 Adola Town   2019-08-01                        1\n 9 Adola Town   2019-09-01                        1\n10 Adola Town   2019-11-01                        1\n# ℹ 11,750 more rows\n\n\nBy default arranging with be in ascending order, you can use desc() to make the output descending.\n\ncase_data %&gt;% \n  filter(data_type == \"presumed\", \n         year(period) == 2019) %&gt;% \n  group_by(woreda, period) %&gt;% \n  summarise(total_presumed_per_month = sum(count)) %&gt;% \n  arrange(desc(total_presumed_per_month))\n\n# A tibble: 11,760 × 3\n# Groups:   woreda [980]\n   woreda           period     total_presumed_per_month\n   &lt;chr&gt;            &lt;date&gt;                        &lt;dbl&gt;\n 1 Goro Baqaqsa     2019-09-01                      838\n 2 Tselemti         2019-11-01                      801\n 3 Tsegede (Tigray) 2019-10-01                      628\n 4 Tsegede (Tigray) 2019-11-01                      620\n 5 Mirab Armacho    2019-10-01                      616\n 6 Metema           2019-10-01                      606\n 7 Tselemti         2019-12-01                      575\n 8 Jawi             2019-10-01                      557\n 9 Chwaka           2019-11-01                      551\n10 Bambasi          2019-10-01                      550\n# ℹ 11,750 more rows\n\n\n\nQuestion 14: What were the total number of confirmed cases in each region in 2019?\n\n\nQuestion 15: What were the total number of cases (presumed and confirmed) in each month for all regions for each year?\n\n\nQuestion 16 (HARD): What were the total number of cases (presumed and confirmed) in the peak (September - December) and the low (January - April) transmission seasons for each woreda in Somali region during 2020?"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#reshaping-data-with-tidyr",
    "href": "dpylr-tidyr-intro.html#reshaping-data-with-tidyr",
    "title": "Data manipulation with *dplyr* and *tidyr*",
    "section": "Reshaping data with *tidyr*",
    "text": "Reshaping data with *tidyr*\nSo far we have covered a bunch of *dplyr* functions for manipulating data, most of which have changed the number of rows and/or columns in our dataframe. However, even though the columns, rows, and values have changed none of these have changed the “structure” of the dataframe. At the end of each function or piped function, the output always followed the conditions we discussed early:\n\nEach column should be a single variable with one data type.\nEach row should be a single observation.\nEach cell should be a single value contains one piece of information.\n\nThis is commonly referred to as “long” format data, and often this means that there are relatively more rows than columns. Typically it is best to work in “long” format data, especially in R, however there are instances when we may want to change the “shape” of our data into the “wide” format. In Microsoft Excel this would be called creating a Pivot Table.\nThe *tidyr* package provides functions for reshaping data, including creating “wide” format pivot tables. To illustrate, lets take a look at records for a single woreda at a single timepoint.\n\ncase_data %&gt;% \n  filter(woreda == \"Awabel\", period == ymd(\"2020-01-01\"))\n\n# A tibble: 2 × 7\n  region zone       woreda  year period     data_type count\n  &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;  &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n1 Amhara East Gojam Awabel  2020 2020-01-01 confirmed    55\n2 Amhara East Gojam Awabel  2020 2020-01-01 presumed      2\n\n\nThe resulting table has six rows, because there are six different types of records included. But what if we wanted to create a table where there is a separate column for each type of record? The pivot_wider() function will allow us to create this kind of “wide” format table. This function requires us to state the column which our column names will come from (names_from), and which column the values in the new columns will come from (values_from).\n\ncase_data %&gt;% \n  filter(woreda == \"Awabel\", period == ymd(\"2020-01-01\")) %&gt;% \n  pivot_wider(names_from = data_type, values_from = count)\n\n# A tibble: 1 × 7\n  region zone       woreda  year period     confirmed presumed\n  &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;  &lt;dbl&gt; &lt;date&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n1 Amhara East Gojam Awabel  2020 2020-01-01        55        2\n\n\nThe resulting output just has one row, but new columns for each of the types of records. This “wide” format is often useful for creating summary tables.\nThe opposite function is called pivot_longer(), which will take in a “wide” format table and output a “long” format table. For pivot_longer() we need to state the column name for the “key” which provides the label, the column names for the values, and which columns we want to pivot on. Here is how we can convert the above example from “wide” format to “long” format.\n\nwide_data &lt;- case_data %&gt;% \n  filter(woreda == \"Awabel\", period == ymd(\"2020-01-01\")) %&gt;% \n  pivot_wider(names_from = data_type, values_from = count)\n\n\nwide_data %&gt;% \n  pivot_longer(\n    names_to = \"data_type\", values_to = \"count\", \n    cols = c(confirmed, presumed))\n\n# A tibble: 2 × 7\n  region zone       woreda  year period     data_type count\n  &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;  &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;\n1 Amhara East Gojam Awabel  2020 2020-01-01 confirmed    55\n2 Amhara East Gojam Awabel  2020 2020-01-01 presumed      2\n\n\n\nQuestion 17: Create a table that contains the total number of confirmed cases each year for each region, then pivot wider to make it so the rows are the year and there is a column for each region.\n\nThink of this as a multi-step process\n1. Filter for confirmed cases\n2. Work out which columns you are grouping by (i.e. what are we grouping over….think geography/time?)\n3. Look at the output so far - what do we now want to sum over for our table?\n4. Now we need to pivot wider - we want to make new columns - where do those names to come from (names_from)?, where will we find the values to populate the new cells (values_from)?\n\nQuestion 17b: Can you make this table longer again, where we now have 3 columns - year, region and count\n\n\nQuestion 18: Create a table that contains the total number of confirmed cases for each woreda and each year in Somali region, now pivot wider to make each woreda its own column where year is now the row - start by writing out the steps 1 by 1 as above"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#final-exercises",
    "href": "dpylr-tidyr-intro.html#final-exercises",
    "title": "Data manipulation with *dplyr* and *tidyr*",
    "section": "Final exercises",
    "text": "Final exercises\n\n\nFor each region, calculate the total number of cases confirmed by RDT each year and present as a wide dataframe, where each column is a year and each row is a region and finally, order the dataframe such that the region with the most cases in 2020 is at the top\n\n\n\n\nFor each woreda in Oromia region, calculate the proportion of total cases in 2020 that were confirmed (confirmed cases / confirmed cases + presumed)\n\n\nTips:\n\nStart by filtering your data - what geographical region, year, and data types do we need?\n\nNow we need to pivot wider - how can we now have data_type as our column names?\n\nNow we need to group_by - what are we grouping by?\n\nAlmost there!! Now we need to sum up some columns - how can we do this?\n\nNow to calculate the proportion - let’s use the mutate function\n\nNow let’s use the ‘select’ function to retrieve the columns we want"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#function-cheatsheet",
    "href": "dpylr-tidyr-intro.html#function-cheatsheet",
    "title": "Data manipulation with *dplyr* and *tidyr*",
    "section": "Function cheatsheet",
    "text": "Function cheatsheet\n\nMain cheat sheet page\n*dplyr* cheat sheet link\nlubridate cheat sheet\ntidyr cheat sheet\n\n*dplyr* functions\n\nselect(): subset columns\nfilter(): subset rows on condition\nmutate(): create new columns\ngroup_by(): group data by one or more column\nsummarise(): create summaries from dataframe (works within groups)\narrange(): reorder dataframe based on ascending order (use desc() to invert)\n\n*tidyr* functions\n\npivot_wider(): go from “long” to “wide” format\npivot_longer(): go from “wide” to “long” format\n\n*lubridate* functions\n\nymd(): convert class to date object based on “YYYY-MM-DD”\nyear(): return the year from a date input\nmonth(): return the month from a date input\nquarter(): return the year quarter (1,2,3,4) from a date input"
  },
  {
    "objectID": "joins.html#joins-overview",
    "href": "joins.html#joins-overview",
    "title": "Joining data in tidyverse",
    "section": "Joins overview",
    "text": "Joins overview\n\nInstalling and Loading the tidyverse Package\nFirst, ensure that you have the tidyverse package installed and loaded.\nLoad the tidyverse package:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\nExample Dataframes\nLet’s create two example dataframes for illustration.\nCreating Dataframe 1:\n\ndf1 &lt;- tibble(\n  id = c(1, 2, 3, 4),\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\")\n)\nprint(df1)\n\n# A tibble: 4 × 2\n     id name   \n  &lt;dbl&gt; &lt;chr&gt;  \n1     1 Alice  \n2     2 Bob    \n3     3 Charlie\n4     4 David  \n\n\nCreating Dataframe 2:\n\ndf2 &lt;- tibble(\n  id = c(1, 2, 4, 5),\n  score = c(85, 90, 88, 92)\n)\nprint(df2)\n\n# A tibble: 4 × 2\n     id score\n  &lt;dbl&gt; &lt;dbl&gt;\n1     1    85\n2     2    90\n3     4    88\n4     5    92\n\n\n\n\nUsing left_join()\nThe left_join() function combines rows from df1 with matching rows from df2. If there is no match, the result will contain NA for the columns from df2.\nSyntax:\nleft_join(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"), ...)\n\nx: The left dataframe.\ny: The right dataframe.\nby: A character vector of variables to join by. If NULL, defaults to all variables with common names in x and y.\n\nExample:\n\njoined_df &lt;- left_join(df1, df2, by = \"id\")\nprint(joined_df)\n\n# A tibble: 4 × 3\n     id name    score\n  &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n1     1 Alice      85\n2     2 Bob        90\n3     3 Charlie    NA\n4     4 David      88\n\n\n\n\nHandling Different Column Names\nIf the key columns have different names in the dataframes, use the by argument to specify the columns to join by.\nExample with Different Column Names:\n\ndf3 &lt;- tibble(\n  student_id = c(1, 2, 4, 5),\n  grade = c(\"A\", \"B\", \"B+\", \"A-\")\n)\n\njoined_df2 &lt;- left_join(df1, df3, by = c(\"id\" = \"student_id\"))\nprint(joined_df2)\n\n# A tibble: 4 × 3\n     id name    grade\n  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;\n1     1 Alice   A    \n2     2 Bob     B    \n3     3 Charlie &lt;NA&gt; \n4     4 David   B+"
  },
  {
    "objectID": "joins.html#example-from-training-data",
    "href": "joins.html#example-from-training-data",
    "title": "Joining data in tidyverse",
    "section": "Example from training data",
    "text": "Example from training data\nComparing cases between different woredas is sometimes desirable when we compare ‘apples with apples’, and make the variable normalized for the population in each woreda. Let us look at the following question.\n\nQuestion 1: We want to identify woredas that have the highest annual confirmed cases per population in 2020.\n\nTo do this task, we need two datasets: one with confirmed cases, and another with population totals, both at the woreda-level. First, let’s load the two datasets we will be using.\n\nconfirmed_cases_annual&lt;- read_csv(\"data/training_case_data_long.csv\")\n\nRows: 94176 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (4): region, zone, woreda, data_type\ndbl  (2): year, count\ndate (1): period\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\npopulation_annual &lt;- read_csv(\"data/training_population_data_long.csv\")\n\nRows: 4905 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): region, zone, woreda\ndbl (2): year, population\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nBefore we join two data frames, we need to identify which columns we can use to join them together.\nThere are two important things we need to do before we can do the join.\n\nIdentify which columns are common in both data frames. Note that the columns we use for joining may not have similar names in both data frames.\nMake sure the common columns (fields) have the same data type. We cannot use columns that have different data types to join two data frames.\n\nThe following script does the task of joining the two data frames, where we choose the case data to be the receiving data frame and the population dataset the server data frame.\n\nannual_incidence &lt;- confirmed_cases_annual %&gt;%\n  filter( year == 2020) %&gt;%\n  group_by (region, zone, woreda, year) %&gt;%\n  summarise(annual_cases = sum(count, na.rm=TRUE)) %&gt;%\n  left_join(population_annual, by = c(\"region\" = \"region\",\n                                      \"zone\" = \"zone\",\n                                      \"woreda\" = \"woreda\",\n                                      \"year\" = \"year\")) %&gt;%\n  mutate(api = annual_cases/ population * 1000) %&gt;%\n  arrange(desc(api))\n\n`summarise()` has grouped output by 'region', 'zone', 'woreda'. You can\noverride using the `.groups` argument.\n\n\nThe function left_join() assumes that the data frame on the left of it is the master (receiver) while the one on its right side is the server data frame. This makes sure all rows on the left side will be included in the output even if there are no corresponding data rows in the data frame on the right side of the function. Any observations from the left side with no match on the right will have an NA value associated with them in the new joined dataset for the joined fields."
  },
  {
    "objectID": "joins.html#conclusion",
    "href": "joins.html#conclusion",
    "title": "Joining data in tidyverse",
    "section": "Conclusion",
    "text": "Conclusion\nUsing the left_join() function from the dplyr package in the tidyverse, you can easily join dataframes based on common keys. This is useful for combining related datasets and performing comprehensive data analysis. By understanding the basics of joins, you can leverage the power of dplyr to handle more complex data manipulations."
  }
]