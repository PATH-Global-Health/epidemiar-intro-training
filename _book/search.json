[
  {
    "objectID": "base-r-intro.html",
    "href": "base-r-intro.html",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "",
    "text": "2 Working with RStudio"
  },
  {
    "objectID": "base-r-intro.html#introduction-to-rstudio",
    "href": "base-r-intro.html#introduction-to-rstudio",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.1 Introduction to RStudio",
    "text": "2.1 Introduction to RStudio\nR is a statistical and graphical software package, and is the very commonly used in many disciplines, including data science, statistics and the environmental and biological sciences The great strengths of R for the research community are:\n\nIt is free, which means anyone can use it.\nIt is open source, which means you can inspect and modify the code within in.\nIt is a community, so researchers around the world have developed code for particular applications that they have made freely available. These are published as ‘packages’ which can be downloaded with just a couple of lines of code.\nBecause of all the community-developed code, there are functions available in R for pretty much every data analysis, statistical method or model, graphic or chart you could ever need. Once you understand how to use R, you will be able to access these.\nThere is an incredible amount of help to be found online for most problems (often on stackoverflow and twitter #rstats)\n\nBy the end of this unit we will have covered\n\nOpening up Rstudio\nSetting up a project in Rstudio\nExploring R, finding help, debugging and writing comments\nDifferent data types\nHow to calculate basic operations on vectors\nHow to use dataframes\nWhat packages are and how to install and use them\nHow to read in external data sources\n\nHopefully you have followed the tutorial we shared and have RStudio downloaded and installed on your computer If you open up Rstudio, you will have 3 panels that look like this\n\nThe first thing you want to do is open up a new R script\n\nYour Rstudio will now have 4 panels\n\nThese screens are:\nTop left: An “R Script” window – this is essentially a text editor where you can write code and commands to be run in the console window. You can edit and correct your work here, and save it so you can use it again. I suggest saving regularly, and keep all your successful code here so you can keep working. Try to use informative script names to help your future self, for example you could save this unit’s script as “R_training_part1”.\nBottom left: This is the “R Console” – this is where the processing is done. You should typically write script code in the “RScript” window and press Ctrl+Enter (or click “Run”) to run them in the console. You may sometimes want to type directly in the console to quickly check that new object looks how you expect them to look or run simple checks that you don’t want to revisit later.\nTop right: The “Environment” tab here shows all the data you’ve loaded and variables/objects you’ve created.\nBottom right: Plots you create will show here. You can also use R Help here: type a function you’re using into the search box and you will get information on its inputs (“Arguments”) and outputs (“Value”), or in the console write a ‘?’ then the function name, i.e. ‘?mean’ to understand how to use the ‘mean’ function."
  },
  {
    "objectID": "base-r-intro.html#setting-up-a-project-in-rstudio",
    "href": "base-r-intro.html#setting-up-a-project-in-rstudio",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.2 Setting up a project in RStudio",
    "text": "2.2 Setting up a project in RStudio\nProjects are a really neat way to work in Rstudio – it means that all the inputs (i.e. data, scripts) and outputs (i.e. plots, summary tables) are stored in the same place. It also means other people can use the same project and rerun our analyses without having to define new filepaths (which can be a pain!) When starting a new project, it is a really good practice to set up a project and associated file structure.\nFirstly go to file -&gt; new project, then select new directory, then new project\n\nDefine your directory (folder) name (I’d suggest something like R_training_workshop_[date])\nThen use the browse option to save this folder somewhere sensible for you (I tend to save things like this in a training folder on my box drive)\n\nNow you have a new project!\nThe next step is to open up a file explorer window and locate this folder\nManually create three new subfolders called data, scripts and plots – everything we use and create during this workshop will be stored here for easy reference and will be able to be reproduced by other or yourself on a different computer"
  },
  {
    "objectID": "base-r-intro.html#exploring-r-finding-help-debugging-and-writing-comments",
    "href": "base-r-intro.html#exploring-r-finding-help-debugging-and-writing-comments",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.3 Exploring R, finding help, debugging and writing comments",
    "text": "2.3 Exploring R, finding help, debugging and writing comments\nWe can now start using R – the simplest thing to do is just to use R as a basic calculator. You can write equations in the script and run them in the console to do simple calculations\n\n20 * 10.5\n\n[1] 210\n\n17 + 23 - 7\n\n[1] 33\n\n\nThere are also a wide range of mathematical functions such as log(), sqrt(), exp()\n\nsqrt(25)\n\n[1] 5\n\n\nIf you don’t know what an inbuilt function does, type a ‘?’ before its name, and the help page will appear on the right hand side of your screen:\n\n?sqrt\n\nA note on errors – these happen ALL THE TIME! A large part of learning to code is learning how to spot and fix your errors – this is called debugging (a great hobby for malaria researchers!)\nFor example, try the following - why do they not work?\n\nsqrt(a)\nsqrt(\"a\")\nSQRT(25)\nsqrt(25))\n\nIf your code isn’t working, the first few things to check are:\n\nHave you spelt the variable names and function names correctly?\n\nDo the objects you’re working with exist?\n\nDo you have the ‘&gt;’ appearing in the console window? If not something didn’t run properly so press Esc a few times until it reappears.\n\nA note on commenting code - it is really good practice to comment your code - this means writing brief descriptions of what you’ve done.\nBy adding the ‘#’ before a line of code, it will not be run as code in your console\n\n# write in a description here so you can remember what you did in the future!\n# here I am using the formula for the area of a circle pi * r^2\narea_of_cirlce &lt;- pi * 4 ^2\n\nYou can also comment out (i.e. add a # before them) lines of code that are maybe wrong or not needed in an analysis before you decide if you need to actually delete them or not."
  },
  {
    "objectID": "base-r-intro.html#data-types",
    "href": "base-r-intro.html#data-types",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.4 Data types",
    "text": "2.4 Data types\nR can store and organize data, parameter, variables of lots of different types – we will now explore a few of them:\n\n2.4.1 Numbers\nSingle numbers can be given names like this\n\nmy_first_variable &lt;- 20\nmy_first_variable\n\n[1] 20\n\n\nImportant to think about how to name variables – do you want to be quick, or do you want your code to make sense to you and others in the future! We can use both uninformative and informative variable names\n\nb &lt;- 2/10\nmalaria_prevalence_2020 &lt;- 2/10\n\nThe “&lt;-” operator tells R to take the number to the right of the symbol and store it in the variable named on the left (You could also use”=“)\nNote: R is case sensitive so for example, the variable ‘malaria_prevalence_2020’ is different than ‘Malaria_prevalence_2020’. Variable names cannot begin with numbers, and you cannot have ‘spaces’ in your variable names (we normally use an underscore ‘_’ where we might want a space).\nYou’ll probably create lots of variable names, and you might forget some of them. You can list all the ones in your session using\n\nls()\n\n[1] \"b\"                       \"has_annotations\"        \n[3] \"malaria_prevalence_2020\" \"my_first_variable\"      \n\n\nYou can overwrite a variable at any point, for example,\n\ntest_variable &lt;- 15\ntest_variable\n\n[1] 15\n\ntest_variable &lt;- 20\ntest_variable\n\n[1] 20\n\n\nIn R programming, the terms ‘variable’ and ‘object’ are often used interchangeably.\nNote: some variable names are not allowed - variables cannot begin with a number or punctuation. It is not a good idea to name variables after in-built R functions - i.e not a good idea to name a variable ‘sum’ or ‘mean’ - we will see very shortly that these words already have a purpose in R!\n\n\n2.4.2 Strings\nStrings are like numbers (in that they represent only one object), but text instead:\n\nmy_first_string  &lt;- \"avocado\"\nmy_first_string\n\n[1] \"avocado\"\n\n\nNow, try this:\n\nmy_first_string  * my_first_string\n\nWhat happens? Why? If you’re not sure what type of data your object is, you can use this function:\n\nclass(my_first_string)\n\n[1] \"character\"\n\nclass(my_first_variable)\n\n[1] \"numeric\"\n\n\nHere, “character” is the name of the datatype of strings, and “double” is a type of number. You can also use the functions “typeof” and “str” to find out about an object (try them out!).\n\n\n2.4.3 Vectors\nVectors and lists are the same kind of object, and represent a set of variables (numbers, strings) in an order. To do this, we use the function ‘c’ which is short for ‘combine’. It combines various objects into a vector. Create these vectors in R:\n\nv1 &lt;- c(1,2,3,4,5)\nv2 &lt;- c(0.1,0.15,0.2,0.4,0.5)\nv3 &lt;- c(\"red\",\"blue\",\"green\",\"orange\",\"black\")\n\nYou can access an individual element by knowing its position in the list. So the 3rd element in the list v1 is found by using square brackets:\n\nv1[3]\n\n[1] 3\n\n\nDifferent types of brackets have different roles in R, so it’s important you use the correct type.\n\nSquare brackets - [] - are used to access elements of vectors (and dataframes and other complex structures)\nRound brackets - () - are used to contain the arguments of a function - i.e. in sqrt(25), the argument to the function ‘sqrt’ is ‘25’\n\n\n\\(\\color{red}{\\text{Question 1: What happens if you try to find an element that doesn’t exist?}}\\)\n\n\n\\(\\color{red}{\\text{e.g. the 0th or 6th element of v1 - how do you type this and what is the output? }}\\)\n\nYou can calculate summary statistics of, and plot, a vector. What do each of these do?:\n\nmean(v1)\nsd(v1) \nvar(v1)\nmin(v1)\nmax(v1)\nsum(v1)\nsum(v1[c(1,4)])\nlength(v1)\nplot(v1)\nplot(v2,v1)\n\n\n\\(\\color{red}{\\text{Question 2: What happens if you try to do use these operations on v3 rather than v1?}}\\)\n\n\n\\(\\color{red}{\\text{Question 3: Try v1* v2 - What has the operator * done to your vectors? Is that what you expected?}}\\)\n\nYou can create a zero-vector of a given length (e.g. 14) like this:\n\nv4 &lt;- rep(0, 14)\n\nThis literally means - we want to repeat the value ‘0’ 14 times – you can learn more about the ‘rep’ function by typing ?rep\nYou can then add values into your vector, for example:\n\nv4[1] &lt;- 10\nv4\n\n [1] 10  0  0  0  0  0  0  0  0  0  0  0  0  0\n\n\n\n\\(\\color{red}{\\text{Question 4:What do you think the following will do?  }}\\)\n\n\n\\(\\color{red}{\\text{v4[2:14] &lt;- c(11:23) Try to guess before you try it!}}\\)\n\nNote: the colon operator ‘:’ allows us to create vectors of consecutuve numbers. For example 1:5 creates a vector from 1 to 5. Quickly try creating a vector from 101 to 200."
  },
  {
    "objectID": "base-r-intro.html#data-frames",
    "href": "base-r-intro.html#data-frames",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.5 Data frames",
    "text": "2.5 Data frames\nData frames are tables that are used for storing data, similar to what you might be used to seeing in excel. R has lots of built-in data sets that you can practice on, including one called CO2. Type\n\n?CO2\n\nto read the documentation. You can load this dataset into R using:\n\ndata(\"CO2\")\n\nTo see the data, you could type CO2 but it’s quite long. Instead you can look at the first few lines by typing\n\n head(CO2)\n\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n3   Qn1 Quebec nonchilled  250   34.8\n4   Qn1 Quebec nonchilled  350   37.2\n5   Qn1 Quebec nonchilled  500   35.3\n6   Qn1 Quebec nonchilled  675   39.2\n\n\nOr if you want to look at more lines (i.e. the first 20)\n\nhead(CO2, n = 20)\n\n   Plant   Type  Treatment conc uptake\n1    Qn1 Quebec nonchilled   95   16.0\n2    Qn1 Quebec nonchilled  175   30.4\n3    Qn1 Quebec nonchilled  250   34.8\n4    Qn1 Quebec nonchilled  350   37.2\n5    Qn1 Quebec nonchilled  500   35.3\n6    Qn1 Quebec nonchilled  675   39.2\n7    Qn1 Quebec nonchilled 1000   39.7\n8    Qn2 Quebec nonchilled   95   13.6\n9    Qn2 Quebec nonchilled  175   27.3\n10   Qn2 Quebec nonchilled  250   37.1\n11   Qn2 Quebec nonchilled  350   41.8\n12   Qn2 Quebec nonchilled  500   40.6\n13   Qn2 Quebec nonchilled  675   41.4\n14   Qn2 Quebec nonchilled 1000   44.3\n15   Qn3 Quebec nonchilled   95   16.2\n16   Qn3 Quebec nonchilled  175   32.4\n17   Qn3 Quebec nonchilled  250   40.3\n18   Qn3 Quebec nonchilled  350   42.1\n19   Qn3 Quebec nonchilled  500   42.9\n20   Qn3 Quebec nonchilled  675   43.9\n\n\nWe can see how big this dataset is using the following command\n\ndim(CO2)\n\n[1] 84  5\n\n\nWhere the first number is the number of rows and the second number is the number of columns.\n\n\\(\\color{red}{\\text{Q5: What are the column names of this dataset?}}\\)\n\nYou can access individual element of a dataframe by knowing its row and column position. For example, “Quebec” is in third row and second column, so we can find it by typing:\n\nCO2[3,2]\n\n[1] Quebec\nLevels: Quebec Mississippi\n\n\nSo the first number refers to the row and the second number the column - we can remember this as CO2[row, column]\nYou can also extract an individual column or row. To extract the sixth row:\n\nCO2[6,]\n\n  Plant   Type  Treatment conc uptake\n6   Qn1 Quebec nonchilled  675   39.2\n\n\nor third column:\n\nCO2[,3]\n\n [1] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n [7] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[13] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[19] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[25] chilled    chilled    chilled    chilled    chilled    chilled   \n[31] chilled    chilled    chilled    chilled    chilled    chilled   \n[37] chilled    chilled    chilled    chilled    chilled    chilled   \n[43] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[49] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[55] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[61] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[67] chilled    chilled    chilled    chilled    chilled    chilled   \n[73] chilled    chilled    chilled    chilled    chilled    chilled   \n[79] chilled    chilled    chilled    chilled    chilled    chilled   \nLevels: nonchilled chilled\n\n\nYou can even subset the data, for example if you wanted to create a new dataframe, CO2_op2, which contains all rows but only the second and third columns:\n\nCO2_op2 &lt;- CO2[,2:3]\nhead(CO2_op2)\n\n    Type  Treatment\n1 Quebec nonchilled\n2 Quebec nonchilled\n3 Quebec nonchilled\n4 Quebec nonchilled\n5 Quebec nonchilled\n6 Quebec nonchilled\n\n\nYou can also check what types of data are in each column using the command\n\nstr(CO2)\n\nClasses 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':  84 obs. of  5 variables:\n $ Plant    : Ord.factor w/ 12 levels \"Qn1\"&lt;\"Qn2\"&lt;\"Qn3\"&lt;..: 1 1 1 1 1 1 1 2 2 2 ...\n $ Type     : Factor w/ 2 levels \"Quebec\",\"Mississippi\": 1 1 1 1 1 1 1 1 1 1 ...\n $ Treatment: Factor w/ 2 levels \"nonchilled\",\"chilled\": 1 1 1 1 1 1 1 1 1 1 ...\n $ conc     : num  95 175 250 350 500 675 1000 95 175 250 ...\n $ uptake   : num  16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...\n - attr(*, \"formula\")=Class 'formula'  language uptake ~ conc | Plant\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_EmptyEnv&gt; \n - attr(*, \"outer\")=Class 'formula'  language ~Treatment * Type\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_EmptyEnv&gt; \n - attr(*, \"labels\")=List of 2\n  ..$ x: chr \"Ambient carbon dioxide concentration\"\n  ..$ y: chr \"CO2 uptake rate\"\n - attr(*, \"units\")=List of 2\n  ..$ x: chr \"(uL/L)\"\n  ..$ y: chr \"(umol/m^2 s)\"\n\n\nThree of the columns are called factors – these are often strings and correspond to a column on which you may want to analyse. They typically represent a variable that has a limited number of values – for example, sex, age group, or province would be considered factors in a malaria dataset.\nWe can see a quick summary of the numeric variables using\n\nsummary(CO2)\n\n     Plant             Type         Treatment       conc          uptake     \n Qn1    : 7   Quebec     :42   nonchilled:42   Min.   :  95   Min.   : 7.70  \n Qn2    : 7   Mississippi:42   chilled   :42   1st Qu.: 175   1st Qu.:17.90  \n Qn3    : 7                                    Median : 350   Median :28.30  \n Qc1    : 7                                    Mean   : 435   Mean   :27.21  \n Qc3    : 7                                    3rd Qu.: 675   3rd Qu.:37.12  \n Qc2    : 7                                    Max.   :1000   Max.   :45.50  \n (Other):42                                                                  \n\n\nIf we want to explore on column of a dataframe, we use the ‘$’ operator – for example,\n\nCO2$Treatment\n\n [1] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n [7] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[13] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[19] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[25] chilled    chilled    chilled    chilled    chilled    chilled   \n[31] chilled    chilled    chilled    chilled    chilled    chilled   \n[37] chilled    chilled    chilled    chilled    chilled    chilled   \n[43] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[49] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[55] nonchilled nonchilled nonchilled nonchilled nonchilled nonchilled\n[61] nonchilled nonchilled nonchilled chilled    chilled    chilled   \n[67] chilled    chilled    chilled    chilled    chilled    chilled   \n[73] chilled    chilled    chilled    chilled    chilled    chilled   \n[79] chilled    chilled    chilled    chilled    chilled    chilled   \nLevels: nonchilled chilled\n\n\nReturns just the ‘treatment’ column\nAnother useful function to quickly explore data is ‘table’ – what does this command return?\n\ntable(CO2$Treatment) \n\n\nnonchilled    chilled \n        42         42 \n\n\n\n\\(\\color{red}{\\text{Q6a: What is the value in the 14th row and 5th column?}}\\)\n\n\n\\(\\color{red}{\\text{Q6b: What are the values in the 1st to 7th rows of the 4th column}}\\)\n\n\n\\(\\color{red}{\\text{Q6c: How many of the samples are from Quebec?}}\\)\n\nWe can also use functions to summarise the numeric data\n\nmean(CO2$uptake)\n\n[1] 27.2131\n\n\n\n\\(\\color{red}{\\text{Q7: What is the range and median of the uptake column? }}\\)\n\nWhat if we only want to know the mean of the ‘uptake’ from Quebec?\nThis is where we’ll touch upon the fact that there are multiple ways to do almost EVERYTHING in R!\nThe traditional ‘base R’ approach uses the ‘which’ function to figure out which bits of the data we want to calculate our sum over –\n\nwhich(CO2$Type == \"Quebec\") \n\nThis returns a vector with the positions in the column CO2$Type where the type is Quebec\nThis is then used inside square brackets to select only these elements of CO2$conc\n\nCO2$conc[which(CO2$Type == \"Quebec\")]\n\n\nmean(CO2$uptake[which(CO2$Type == \"Quebec\")])\n\n[1] 33.54286\n\n\nThe tidyverse approach, which we are covering in depth tomorrow uses a function called filter\n\nop1 = filter(CO2, Type == \"Quebec\")\nmean(op1$uptake)\n\n[1] 33.54286\n\n\nWe can also filter by 2 or more criteria\n\nop2 = filter(CO2, Type == \"Quebec\", Treatment == \"chilled\")\nmean(op2$uptake)\n\n[1] 31.75238\n\n\n\n\\(\\color{red}{\\text{Can you now fill in this table -  we want the **MEDIAN** uptake value for each treatment-type combination}}\\)"
  },
  {
    "objectID": "base-r-intro.html#packages",
    "href": "base-r-intro.html#packages",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.6 Packages",
    "text": "2.6 Packages\nR packages are collections of functions and data sets developed by the community.\nThey increase the power of R by improving existing base R functionalities, or by adding new ones. There seems to be an R package that does almost everything – from the most widely used ones\n\ntidyverse - for data manipulation and analysis\nsf - everything spatial and map related\nggplot2 - for a wide range of plots\njanitor - cleaning data using standard conventions\n\nTo the plain ridiculous:\n\nwesanderson - A library of colour pallettes based on Wes Anderson movies\ncowsay - Printed animals that say messages\n\n\nnames(wes_palettes)\n\n [1] \"BottleRocket1\"  \"BottleRocket2\"  \"Rushmore1\"      \"Rushmore\"      \n [5] \"Royal1\"         \"Royal2\"         \"Zissou1\"        \"Darjeeling1\"   \n [9] \"Darjeeling2\"    \"Chevalier1\"     \"FantasticFox1\"  \"Moonrise1\"     \n[13] \"Moonrise2\"      \"Moonrise3\"      \"Cavalcanti1\"    \"GrandBudapest1\"\n[17] \"GrandBudapest2\" \"IsleofDogs1\"    \"IsleofDogs2\"   \n\ncols = wes_palette(\"GrandBudapest1\")\ncols\n\n\n\n\n\nsay(\"My favourite R package is called purrr\", by = \"cat\")\n\n\n -------------- \nMy favourite R package is called purrr \n --------------\n    \\\n      \\\n        \\\n            |\\___/|\n          ==) ^Y^ (==\n            \\  ^  /\n             )=*=(\n            /     \\\n            |     |\n           /| | | |\\\n           \\| | |_|/\\\n      jgs  //_// ___/\n               \\_)\n  \n\n\n\n2.6.1 Installing and using a package\nThere are two stages to using a package\n\nInstalling – think of this as buying a book and adding it to your library – this is an action you only ever need to do once.\nLoading – think of this as taking the book from your library shelf – you need to do this each time you want to use it.\n\nWe’re going to try and install and use a package called janitor (https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html)\n\ninstall.packages(“janitor”)\nlibrary(janitor)\n\nWhen installing a new package, I typically either write it straight in the console or comment it out in my script to avoid reinstalling every time I run my code\n\n# install.packages(“janitor”)\n\nIf you want to see all the functions available in a package, there are typically pdf’s online of each function and often user guides.\nYou can also remind yourself of functions in a package by typing, for example,\n\njanitor::\n\nIn your console or script\n\n\\(\\color{red}{\\text{Q8: Can you install and load either **wesanderson** or **cowsay** packages}}\\)\n\n\n\\(\\color{red}{\\text{and generate either a Wes Anderson colour palette or a speaking animal?}}\\)"
  },
  {
    "objectID": "base-r-intro.html#reading-in-data",
    "href": "base-r-intro.html#reading-in-data",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.7 Reading in data",
    "text": "2.7 Reading in data\nNormally when we analyse data in R we are reading in external data sources - here we learn how to load those into R.\nIf this training has been shared with you, you should have access to a file called district-cases-wide.csv - now manually save this into the data folder in your project directory.\nWe can now read this into R\n\ndat &lt;- read_csv(\"data/district-cases-wide.csv\")\n\nThis is an aggregated dataset from DHIS2 in Zambia - we have a row for each district-month.\nWe have 5 key bits of data (as well as date, province, district):\n\nclinical - number of unconfirmed malaria cases detected at the HF (from HMIS DHIS2)\nconfirmed - number of RDT confirmed malaria cases detected at the HF (from HMIS DHIS2)\ntested - number of RDTs conducted at the HF (from HMIS DHIS2)\nconfirmed_passive_chw - number of RDT confirmed cases detected passively by CHWs (from NMEC DHIS2)\ntested_passive_chw - number of RDTs conducted passively by CHWs (from NMEC DHIS2)\n\n\nhead(dat)\n\n# A tibble: 6 × 8\n  period     province district   Clinical Confirmed Tested Confirmed_Passive_CHW\n  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;                 &lt;dbl&gt;\n1 2018-01-01 Central  Chibombo         26      1897   8215                   NaN\n2 2018-01-01 Central  Chisamba        NaN      2192   7772                   NaN\n3 2018-01-01 Central  Chitambo         33      6011   3993                   NaN\n4 2018-01-01 Central  Itezhi-te…      NaN       890   5007                   897\n5 2018-01-01 Central  Kabwe            32      3600  13271                   NaN\n6 2018-01-01 Central  Kapiri-Mp…      507     21527  18061                   NaN\n# ℹ 1 more variable: Tested_Passive_CHW &lt;dbl&gt;\n\n\nNote that (depending on your screen size) a few variables are not visible in the console. You can remedy this with the following code:\n\noptions(dplyr.width = Inf)\n\nWe can now apply some of the tools we’ve learnt today to analyse some aggregated DHIS2 data from Zambia.\n\n2.7.1 Example 1: How many confirmed malaria cases (HF) there were in Katete district in 2020?\n\ndat &lt;- dat %&gt;% mutate(year = lubridate::year(period))\n\nop1 = filter(dat, district == \"Katete\", year == 2020)\nop1\n\n# A tibble: 12 × 9\n   period     province district Clinical Confirmed Tested Confirmed_Passive_CHW\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;                 &lt;dbl&gt;\n 1 2020-01-01 Eastern  Katete        NaN      2799   9777                  3586\n 2 2020-02-01 Eastern  Katete        NaN      2331  10066                  3573\n 3 2020-03-01 Eastern  Katete        NaN      5059  15256                 11604\n 4 2020-04-01 Eastern  Katete        NaN      6855  14222                 21573\n 5 2020-05-01 Eastern  Katete        NaN      7435  13215                 15851\n 6 2020-06-01 Eastern  Katete        NaN      4910  10973                  7121\n 7 2020-07-01 Eastern  Katete        NaN      2182   6686                  3246\n 8 2020-08-01 Eastern  Katete        NaN      1074   5469                  1885\n 9 2020-09-01 Eastern  Katete        NaN       751   4844                  1296\n10 2020-10-01 Eastern  Katete        NaN       636   4971                  1179\n11 2020-11-01 Eastern  Katete        NaN       416   5339                   961\n12 2020-12-01 Eastern  Katete        NaN       422   3749                   753\n# ℹ 2 more variables: Tested_Passive_CHW &lt;dbl&gt;, year &lt;dbl&gt;\n\nsum(op1$confirmed)\n\nWarning: Unknown or uninitialised column: `confirmed`.\n\n\n[1] 0\n\n\n\n\n2.7.2 Example 2: What was total number of RDTs conducted by HFs and CHWs in Sinazongwe district in 2019?\n\nop2 = filter(dat, district == \"Sinazongwe\", year == 2019)\nop2\n\n# A tibble: 12 × 9\n   period     province district  Clinical Confirmed Tested Confirmed_Passive_CHW\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;                 &lt;dbl&gt;\n 1 2019-01-01 Southern Sinazong…      NaN      1663   6140                  1381\n 2 2019-02-01 Southern Sinazong…       96      2167   7324                  1405\n 3 2019-03-01 Southern Sinazong…       20      3618   8542                  3735\n 4 2019-04-01 Southern Sinazong…        2      1134   4192                   894\n 5 2019-05-01 Southern Sinazong…        6      2725   6332                  2585\n 6 2019-06-01 Southern Sinazong…      187      1682   5116                  1049\n 7 2019-07-01 Southern Sinazong…      NaN      1733   6137                  1027\n 8 2019-08-01 Southern Sinazong…        1      1269   5528                   865\n 9 2019-09-01 Southern Sinazong…      NaN      1022   4275                   713\n10 2019-10-01 Southern Sinazong…      NaN       624   3180                   381\n11 2019-11-01 Southern Sinazong…      NaN       212   1865                   100\n12 2019-12-01 Southern Sinazong…      NaN       474   2244                   193\n# ℹ 2 more variables: Tested_Passive_CHW &lt;dbl&gt;, year &lt;dbl&gt;\n\nsum(op2$tested) + sum(op2$tested_passive_chw)\n\nWarning: Unknown or uninitialised column: `tested`.\n\n\nWarning: Unknown or uninitialised column: `tested_passive_chw`.\n\n\n[1] 0\n\n\n\n\\(\\color{red}{\\text{Question 9: What happens if we repeat this for Chama district?, Why?}}\\)\n\nIt’s really important to look at your data closely! We can fix this problem by using the following logic:\n\ntest_vector &lt;- c(1,5,8,3,NA,6)\nsum(test_vector)\n\n[1] NA\n\nsum(test_vector, na.rm=TRUE)\n\n[1] 23\n\n\nHow did we know to do this? We looked at the help file for sum by using ?sum and saw the option to add an argument that removes NAs.\n\n\\(\\color{red}{\\text{Question 9 cont.: Now we know how to remove NAs, how many RDTs were conducted in Chama in 2019?}}\\)\n\nWe will spend the next chapter learning about more ways to manipulate and aggregate data - but for now, you can try and answer these questions using the examples above!\n\n\\(\\color{teal}{\\text{Final exercise 1: What is the total number of cases (all HF and CHW) in Western province in 2020? }}\\)\n\n\n\\(\\color{teal}{\\text{Final exercise 2: How many RDTs have been conducted by CHWs in 2021 compared to 2020?}}\\)\n\n\n\\(\\color{teal}{\\text{Final exercise 3: In 2020, were there more malaria cases in Luapula or Muchinga?}}\\)"
  },
  {
    "objectID": "base-r-intro.html#cheat-sheet-of-functions-from-this-unit",
    "href": "base-r-intro.html#cheat-sheet-of-functions-from-this-unit",
    "title": "1  Introduction to R and Rstudio and basic functions",
    "section": "2.8 Cheat sheet of functions from this unit",
    "text": "2.8 Cheat sheet of functions from this unit\n\nsqrt()\nexp()\nlog()\nrep()\nsummary()\ntable()\ndim()\nmean()\nmedian()\nrange()\nsum()\nstr()\nclass()\nhead()\nwhich()\nread.csv()\n\n(And three functions from the tidyverse world)\n\nfilter()\nsummarise()\npull()"
  },
  {
    "objectID": "if-statements.html",
    "href": "if-statements.html",
    "title": "2  Using if statements",
    "section": "",
    "text": "Conditional statements are fundamental in programming, allowing for decision-making based on different conditions. In R, the primary conditional statement is the if statement, which can be used alone or combined with else and else if for more complex logic.\n\n2.0.1 Basic If Statement\nThe basic if statement checks a condition and executes a block of code if the condition is true.\nSyntax:\nif (condition) {\n  # code to execute if the condition is true\n}\nExample:\nx &lt;- 10\n\nif (x &gt; 5) {\n  print(\"x is greater than 5\")\n}\n\n\n2.0.2 If-Else Statement\nTo execute a block of code when the condition is false, use an else statement.\nSyntax:\nif (condition) {\n  # code to execute if the condition is true\n} else {\n  # code to execute if the condition is false\n}\nExample:\nx &lt;- 3\n\nif (x &gt; 5) {\n  print(\"x is greater than 5\")\n} else {\n  print(\"x is not greater than 5\")\n}\n\n\n2.0.3 If-Else If-Else Statement\nFor multiple conditions, use else if to check additional conditions.\nSyntax:\nif (condition1) {\n  # code to execute if condition1 is true\n} else if (condition2) {\n  # code to execute if condition2 is true\n} else {\n  # code to execute if none of the conditions are true\n}\nExample:\nx &lt;- 7\n\nif (x &gt; 10) {\n  print(\"x is greater than 10\")\n} else if (x &gt; 5) {\n  print(\"x is greater than 5 but less than or equal to 10\")\n} else {\n  print(\"x is 5 or less\")\n}\n\n\n2.0.4 Nested If Statements\nYou can also nest if statements inside one another to check multiple levels of conditions.\nExample:\nx &lt;- 15\ny &lt;- 20\n\nif (x &gt; 10) {\n  if (y &gt; 15) {\n    print(\"x is greater than 10 and y is greater than 15\")\n  } else {\n    print(\"x is greater than 10 but y is not greater than 15\")\n  }\n} else {\n  print(\"x is 10 or less\")\n}\n\n\n2.0.5 Vectorized If Statements\nWhen working with vectors, ifelse is a more efficient way to apply conditional logic.\nSyntax:\nifelse(test, yes, no)\n\ntest: A logical condition.\nyes: The value to return if the condition is true.\nno: The value to return if the condition is false.\n\nExample:\nx &lt;- c(2, 7, 5, 10)\n\nresult &lt;- ifelse(x &gt; 5, \"Greater than 5\", \"5 or less\")\nprint(result)\n\n\n2.0.6 Conclusion\nUsing if statements in R allows you to execute code based on conditions, making your programs more dynamic and flexible. Whether you’re using a simple if statement, adding else and else if for more complex logic, or applying conditional logic to vectors with ifelse, mastering these constructs is essential for effective programming in R."
  },
  {
    "objectID": "if-statements.html#basic-if-statement",
    "href": "if-statements.html#basic-if-statement",
    "title": "3  Using if statements",
    "section": "3.1 Basic If Statement",
    "text": "3.1 Basic If Statement\nThe basic if statement checks a condition and executes a block of code if the condition is true.\nSyntax:\nif (condition) {\n  # code to execute if the condition is true\n}\nExample:\nx &lt;- 10\n\nif (x &gt; 5) {\n  print(\"x is greater than 5\")\n}"
  },
  {
    "objectID": "if-statements.html#if-else-statement",
    "href": "if-statements.html#if-else-statement",
    "title": "3  Using if statements",
    "section": "3.2 If-Else Statement",
    "text": "3.2 If-Else Statement\nTo execute a block of code when the condition is false, use an else statement.\nSyntax:\nif (condition) {\n  # code to execute if the condition is true\n} else {\n  # code to execute if the condition is false\n}\nExample:\nx &lt;- 3\n\nif (x &gt; 5) {\n  print(\"x is greater than 5\")\n} else {\n  print(\"x is not greater than 5\")\n}\n\n3.2.1 If-Else If-Else Statement\nFor multiple conditions, use else if to check additional conditions.\nSyntax:\nif (condition1) {\n  # code to execute if condition1 is true\n} else if (condition2) {\n  # code to execute if condition2 is true\n} else {\n  # code to execute if none of the conditions are true\n}\nExample:\nx &lt;- 7\n\nif (x &gt; 10) {\n  print(\"x is greater than 10\")\n} else if (x &gt; 5) {\n  print(\"x is greater than 5 but less than or equal to 10\")\n} else {\n  print(\"x is 5 or less\")\n}"
  },
  {
    "objectID": "if-statements.html#nested-if-statements",
    "href": "if-statements.html#nested-if-statements",
    "title": "3  Using if statements",
    "section": "3.3 Nested If Statements",
    "text": "3.3 Nested If Statements\nYou can also nest if statements inside one another to check multiple levels of conditions.\nExample:\nx &lt;- 15\ny &lt;- 20\n\nif (x &gt; 10) {\n  if (y &gt; 15) {\n    print(\"x is greater than 10 and y is greater than 15\")\n  } else {\n    print(\"x is greater than 10 but y is not greater than 15\")\n  }\n} else {\n  print(\"x is 10 or less\")\n}\n\n3.3.1 Vectorized If Statements\nWhen working with vectors, ifelse is a more efficient way to apply conditional logic.\nSyntax:\nifelse(test, yes, no)\n\ntest: A logical condition.\nyes: The value to return if the condition is true.\nno: The value to return if the condition is false.\n\nExample:\nx &lt;- c(2, 7, 5, 10)\n\nresult &lt;- ifelse(x &gt; 5, \"Greater than 5\", \"5 or less\")\nprint(result)"
  },
  {
    "objectID": "if-statements.html#conclusion",
    "href": "if-statements.html#conclusion",
    "title": "3  Using if statements",
    "section": "3.4 Conclusion",
    "text": "3.4 Conclusion\nUsing if statements in R allows you to execute code based on conditions, making your programs more dynamic and flexible. Whether you’re using a simple if statement, adding else and else if for more complex logic, or applying conditional logic to vectors with ifelse, mastering these constructs is essential for effective programming in R."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EpidemiaR Introductiory Materials",
    "section": "",
    "text": "Background\nThis book contains background material for general R basics, as well as some of the packages and functions that we will use during the EpidemiaR training lessons.\nAdditional materials and resources:"
  },
  {
    "objectID": "more-base.html#concatenating-strings-and-printing-messages",
    "href": "more-base.html#concatenating-strings-and-printing-messages",
    "title": "4  More base R functions",
    "section": "4.1 Concatenating strings and printing messages",
    "text": "4.1 Concatenating strings and printing messages\nIn R, paste() and paste0() are functions used to concatenate strings, while message() is used to print messages to the console. Understanding these functions helps in creating more informative and readable outputs, as well as in debugging and providing user feedback.\n\n4.1.1 paste() Function\nThe paste() function concatenates strings with a specified separator.\nSyntax:\npaste(..., sep = \" \", collapse = NULL)\n\n...: One or more R objects to be concatenated.\nsep: A string to separate the terms (default is a space).\ncollapse: An optional string to separate the results when concatenating vectors.\n\nExamples:\n\nConcatenating strings with spaces:\nstr1 &lt;- \"Hello\"\nstr2 &lt;- \"World\"\nresult &lt;- paste(str1, str2)\nprint(result)\n# Output: \"Hello World\"\nUsing a different separator:\nresult &lt;- paste(\"A\", \"B\", \"C\", sep = \"-\")\nprint(result)\n# Output: \"A-B-C\"\nCollapsing a vector into a single string:\nwords &lt;- c(\"apple\", \"banana\", \"cherry\")\nresult &lt;- paste(words, collapse = \", \")\nprint(result)\n# Output: \"apple, banana, cherry\"\n\n\n\n4.1.2 paste0() Function\nThe paste0() function is a shortcut for paste(..., sep = \"\"). It concatenates strings without any separator.\nSyntax:\npaste0(...)\n\n...: One or more R objects to be concatenated.\n\nExamples:\n\nConcatenating strings without spaces:\nstr1 &lt;- \"Hello\"\nstr2 &lt;- \"World\"\nresult &lt;- paste0(str1, str2)\nprint(result)\n# Output: \"HelloWorld\"\nConcatenating multiple strings:\nresult &lt;- paste0(\"A\", \"B\", \"C\")\nprint(result)\n# Output: \"ABC\"\n\n\n\n4.1.3 message() Function\nThe message() function is used to print a message to the console. Unlike print(), it sends its output to the standard message stream and is often used for warnings, informational messages, and debugging.\nSyntax:\nmessage(...)\n\n...: One or more R objects to be printed.\n\nExamples:\n\nPrinting a simple message:\nmessage(\"This is an informational message.\")\n# Output: This is an informational message.\nCombining paste() with message():\nname &lt;- \"John\"\nage &lt;- 30\nmessage(paste(\"Name:\", name, \"Age:\", age))\n# Output: Name: John Age: 30\nCombining paste0() with message():\nprefix &lt;- \"ID_\"\nid &lt;- 1234\nmessage(paste0(\"Generated ID: \", prefix, id))\n# Output: Generated ID: ID_1234"
  },
  {
    "objectID": "more-base.html#loading-objects-and-data-files",
    "href": "more-base.html#loading-objects-and-data-files",
    "title": "4  More base R functions",
    "section": "4.2 Loading objects and data files",
    "text": "4.2 Loading objects and data files\n\n4.2.1 R objects and data\nR provides several functions for saving and loading data, allowing you to preserve your workspace and share data with others. The save() and load() functions save and restore entire R workspaces, while saveRDS() and readRDS() handle individual R objects.\n\n4.2.1.1 save() and load() Functions\nThe save() function saves R objects to a specified file, which can be loaded back into the R environment using the load() function.\nsave() Syntax:\nsave(..., file)\n\n...: R objects to be saved.\nfile: A character string naming the file to save the data to.\n\nload() Syntax:\nload(file)\n\nfile: A character string naming the file to load the data from.\n\nExamples:\n\nSaving multiple objects:\nx &lt;- 1:10\ny &lt;- letters[1:10]\nsave(x, y, file = \"data.RData\")\nLoading the saved objects:\nload(\"data.RData\")\nprint(x)\nprint(y)\n\n\n\n4.2.1.2 saveRDS() and readRDS() functions\nThe saveRDS() function saves a single R object to a file, and readRDS() restores it. Unlike save(), saveRDS() does not save the object name, so you can assign it any name when you load it.\nsaveRDS() Syntax:\nsaveRDS(object, file)\n\nobject: The R object to be saved.\nfile: A character string naming the file to save the object to.\n\nreadRDS() Syntax:\nreadRDS(file)\n\nfile: A character string naming the file to read the object from.\n\nExamples:\n\nSaving a single object:\nz &lt;- matrix(1:9, nrow = 3)\nsaveRDS(z, file = \"matrix.RDS\")\nLoading the saved object:\nmy_matrix &lt;- readRDS(\"matrix.RDS\")\nprint(my_matrix)\n\nUsing load(), save(), saveRDS(), and readRDS() functions in R enables you to efficiently save and restore your data. Whether you need to save entire workspaces or individual objects, these functions provide flexible options for data persistence and sharing.\n\n\n\n4.2.2 CSV and Excel files"
  },
  {
    "objectID": "more-base.html#loading-csv-and-excel-files-into-r",
    "href": "more-base.html#loading-csv-and-excel-files-into-r",
    "title": "4  More base R functions",
    "section": "4.3 Loading CSV and Excel Files into R",
    "text": "4.3 Loading CSV and Excel Files into R\nReading data from CSV and Excel files is a common task in data analysis. R provides functions to easily load these files into your workspace for analysis.\n\n4.3.0.1 Loading CSV Files\nTo load CSV files, use the read.csv() or readr::read_csv() functions. The readr package’s read_csv() is often preferred for its speed and efficiency.\nread.csv() Syntax:\ndata &lt;- read.csv(file, header = TRUE, sep = \",\")\n\nfile: Path to the CSV file.\nheader: Logical value indicating if the file contains a header row.\nsep: Character separating the values (default is a comma).\n\nExample:\ndata &lt;- read.csv(\"path/to/yourfile.csv\")\nprint(head(data))\nreadr::read_csv() Syntax:\nlibrary(readr)\ndata &lt;- read_csv(\"path/to/yourfile.csv\")\nprint(head(data))\n\n\n4.3.0.2 Loading Excel Files\nTo load Excel files, use the readxl package, which provides the read_excel() function.\nSyntax:\nlibrary(readxl)\ndata &lt;- read_excel(path, sheet = 1)\n\npath: Path to the Excel file.\nsheet: Sheet number or name to read from (default is the first sheet).\n\nExample:\nlibrary(readxl)\ndata &lt;- read_excel(\"path/to/yourfile.xlsx\", sheet = \"Sheet1\")\nprint(head(data))\nUsing read.csv(), readr::read_csv(), and read_excel() functions, you can easily load CSV and Excel files into R for analysis. These functions provide a straightforward way to import your data and begin your analysis quickly."
  },
  {
    "objectID": "more-base.html#source-an-entire-r-script",
    "href": "more-base.html#source-an-entire-r-script",
    "title": "4  More base R functions",
    "section": "4.4 Source an entire R script",
    "text": "4.4 Source an entire R script\nSometimes you may want to run an entire script all at once. This can be useful when using multiple scripts that must be run in a structured order, or when storing all of your custom functions in a separate script.\nWe can use the source() function to execute an entire script at once.\nExample:\nscript_file &lt;- file.path(\"path/to/yourscript.R\")\nsource(script_file)\nThis will run all of the operations in that script in your active R sessions. All libraries, variables, and functions that are loaded or created in your sourced script will then be available in your session.\nYou can use the exists() function to create to make sure that the path you provide leads to an existing script. This function will return either TRUE or FALSE. This is also useful for checking if a data file is present in an expected location before loading and execute additional functions, especially when combined in an if statement.\nA few things to watch out for: 1. Loading libraries may cause name conflicts for functions with shared names. 2. Similarly, sourcing a script will overwrite existing variables with the same name. 3. Sourcing script may take a long time depending on the complexity of the script."
  },
  {
    "objectID": "more-base.html#additional-base-r-functions",
    "href": "more-base.html#additional-base-r-functions",
    "title": "4  More base R functions",
    "section": "4.5 Additional base R functions",
    "text": "4.5 Additional base R functions\nHere are some additional functions that you may encounter in during the EpidemiaR Training sections.\n\nSys.Date()/Sys.Time() will return the active data or time.\nnrow() will return the number of rows in a dataframe.\nlength() will return the number of objects in a vector, or the number of columns in a dataframe.\nunique() will return all of the unique entries in a vector."
  },
  {
    "objectID": "pipes.html#pipes-in-tidyverse",
    "href": "pipes.html#pipes-in-tidyverse",
    "title": "5  Chaining multiple steps using pipes",
    "section": "5.1 Pipes in tidyverse",
    "text": "5.1 Pipes in tidyverse\nTo use pipes, you’ll need to install and load the magrittr or tidyverse package. Remember that you only need to install the package one time, but you will have to load tidyverse if you want to use the pipe in a given script.\nInstall tidyverse:\ninstall.packages(\"tidyverse\")\nLoad the tidyverse package:\nlibrary(tidyverse)\n\n5.1.1 Basic Pipe Syntax\nThe pipe operator %&gt;% takes the output from the left-hand side and uses it as the first argument for the function on the right-hand side.\nSyntax:\ndata %&gt;% \n  function1() %&gt;%\n  function2() %&gt;%\n  function3()\n\n5.1.1.1 Example without Pipes\nConsider the following operations on a data frame without using pipes:\nExample:\nlibrary(dplyr)\n\ndata &lt;- mtcars\nfiltered_data &lt;- filter(data, cyl == 6)\nselected_data &lt;- select(filtered_data, mpg, hp)\nsummarized_data &lt;- summarize(selected_data, mean_mpg = mean(mpg), mean_hp = mean(hp))\n\nprint(summarized_data)\n\n\n5.1.1.2 Example with Pipes\nThe same operations can be performed more concisely using pipes:\nExample:\nlibrary(dplyr)\n\nmtcars %&gt;%\n  filter(cyl == 6) %&gt;%\n  select(mpg, hp) %&gt;%\n  summarize(mean_mpg = mean(mpg), mean_hp = mean(hp)) %&gt;%\n  print()\n\n\n\n5.1.2 Using Pipes with Custom Functions\nPipes can also be used with custom functions. Define your function and use it within a pipe.\nExample:\ncustom_function &lt;- function(df) {\n  df %&gt;%\n    filter(gear == 4) %&gt;%\n    select(mpg, wt)\n}\n\nmtcars %&gt;%\n  custom_function() %&gt;%\n  head()\n\n\n5.1.3 Using the Dot Placeholder\nSometimes, the data does not automatically fit as the first argument in the next function. In such cases, use the dot (.) as a placeholder.\nExample:\nmtcars %&gt;%\n  filter(cyl == 4) %&gt;%\n  select(mpg, wt) %&gt;%\n  {\n    n &lt;- nrow(.)\n    mean_wt &lt;- mean(.$wt)\n    data.frame(n = n, mean_wt = mean_wt)\n  }\n\n\n5.1.4 Nesting Pipes\nPipes can be nested for more complex operations. This is particularly useful when combining multiple data frames or performing multi-step operations.\nExample:\ndata1 &lt;- mtcars %&gt;%\n  filter(cyl == 6) %&gt;%\n  select(mpg, hp)\n\ndata2 &lt;- mtcars %&gt;%\n  filter(cyl == 4) %&gt;%\n  select(mpg, wt)\n\ncombined_data &lt;- bind_rows(data1, data2)\nprint(combined_data)\nUsing pipes in R enhances code readability and efficiency, allowing you to write more concise and maintainable code. Whether performing simple data manipulations or complex data transformations, pipes streamline your workflow by reducing the need for intermediate variables and nested function calls."
  },
  {
    "objectID": "pipes.html#native-pipe-operator-in-r-r-4.1",
    "href": "pipes.html#native-pipe-operator-in-r-r-4.1",
    "title": "5  Chaining multiple steps using pipes",
    "section": "5.2 Native Pipe Operator in R (R 4.1+)",
    "text": "5.2 Native Pipe Operator in R (R 4.1+)\nStarting with R version 4.1, a native pipe operator (|&gt;) was introduced, providing an alternative to the %&gt;% pipe from the magrittr package. The native pipe is part of the base R language, eliminating the need to load external packages for basic piping operations.\n\n5.2.1 Basic Syntax\nThe native pipe operator works similarly to the %&gt;% operator but uses |&gt; instead.\nSyntax:\ndata |&gt; \n  function1() |&gt;\n  function2() |&gt;\n  function3()\nHere is an example using traditional function chaining without the native pipe:\nExample:\ndata &lt;- mtcars\nfiltered_data &lt;- filter(data, cyl == 6)\nselected_data &lt;- select(filtered_data, mpg, hp)\nsummarized_data &lt;- summarize(selected_data, mean_mpg = mean(mpg), mean_hp = mean(hp))\n\nprint(summarized_data)\nThe same operations can be performed more concisely using the native pipe:\nExample:\nmtcars |&gt;\n  (\\(df) filter(df, cyl == 6))() |&gt;\n  (\\(df) select(df, mpg, hp))() |&gt;\n  (\\(df) summarize(df, mean_mpg = mean(mpg), mean_hp = mean(hp)))() |&gt;\n  print()\n\n\n5.2.2 Using Native Pipe with Custom Functions\nNative pipes can also be used with custom functions, providing a clean and readable way to chain operations.\nExample:\ncustom_function &lt;- function(df) {\n  df |&gt;\n    filter(gear == 4) |&gt;\n    select(mpg, wt)\n}\n\nmtcars |&gt;\n  custom_function() |&gt;\n  head()\n\n\n5.2.3 Using the Dot Placeholder\nWhile the native pipe does not use the dot (.) placeholder in the same way as %&gt;%, it can still be used flexibly with anonymous functions.\nExample:\nmtcars |&gt;\n  (\\(df) filter(df, cyl == 4))() |&gt;\n  (\\(df) select(df, mpg, wt))() |&gt;\n  (\\(df) {\n    n &lt;- nrow(df)\n    mean_wt &lt;- mean(df$wt)\n    data.frame(n = n, mean_wt = mean_wt)\n  })()\nThe introduction of the native pipe operator in R 4.1 provides a built-in and efficient way to chain operations, enhancing code readability without relying on external packages. While it lacks some of the tools of %&gt;%, such as the dot placeholder, it integrates seamlessly with base R functions and custom workflows.\nYou may encounter both types of pipes, and most often they work interchangeably. However, it is important to note the stuble differences between the tidyverse and native pipes, especially when debugging errors.\nAlso, remember that the native pipe is relatively new (R 4.1 waws released in 2022), so if you have not updated R in a long time than you will not have acesss to the native pipe."
  },
  {
    "objectID": "dpylr-tidyr-intro.html",
    "href": "dpylr-tidyr-intro.html",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "",
    "text": "7 Data Manipulation with dplyr and tidyr"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#the-power-of-packages",
    "href": "dpylr-tidyr-intro.html#the-power-of-packages",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "7.1 The power of packages",
    "text": "7.1 The power of packages\nOne of the great things about using R are the thousands of available packages, which provide additional functions for many analytical tasks, such as data cleaning, statistical modelling, mapping, and much more. R packages are open-source, which means that they are free to use and maintained by the R community.\n\n7.1.1 Installing and loading packages\nThroughout the rest of this training we will use a set of R packages manipulating data and creating plots and maps. As we covered in Chapter 1, we first need to install the package on our computer using the install.packages() function. This only needs to be done one time (you probably already did this earlier).\n\ninstall.packages(\"dplyr\")\n\nOnce the package has been installed, we can load it into our current R session using the library() function. Unlike installing, you will need to load the library each time you want to use it. This is because some libraries may have functions with the same names as other libraries or as our variables.\n\nlibrary(dplyr) \n\nFor the next series of exercises, we will be using a group of packages which have been designed to work together to do common data science tasks. This group of packages is called the “Tidyverse”, because it is designed to work within the “tidy” data philosophy:\n\n\nSome important qualities of this philosophy is that our data should have the following format:\n\nEach column should be a single variable with one data type.\nEach row should be a single observation.\nEach cell should be a single value contains one piece of information.\n\nWe can install all of these packages at once using install.package(\"tidyverse\"). Remember that we only install the package once, so it is actually better to type this directly into the console instead of in our R script since it does not need to be repeated. Also be aware that this may take some time especially if internet quality is poor. After the package has finished installing it is ready to be loaded into our R session.\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#reading-data-into-r",
    "href": "dpylr-tidyr-intro.html#reading-data-into-r",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "7.2 Reading data into R",
    "text": "7.2 Reading data into R\nOnce the tidyverse package is loaded into our session we will have access to all of the functions in each of the Tidyverse packages. This includes packages for loading, manipulating, and plotting data. The function we will use is read_csv() to read in the district-level data we worked with previously. Note that this is similar but slightly different to the read.csv() function we used in our previous exercise.\n\nscram_num &lt;- function(x, offset = 0.5){\n  set.seed(10)\n  round(runif(1, x*offset, x*(1+offset)))\n}\n\ncase_data &lt;- read_csv(\"data/district-cases-long.csv\") %&gt;%\n  rowwise() %&gt;%\n  mutate(count = scram_num(count))\n\nThis is the same dataset we used in Chapter 1 (values scrambled to prevent unauthorized access to confidential data), only this time we called the object case_data instead of dat. It’s good practice to name your objects something short and meaningful, so that it’s easy to type and remember (this is especially useful when you have multiple data objects).\nAlso, in this file the data are organized in “long” format, whereas the file used in Chapter 1 was in “wide” format. We will discuss the difference between “long” and “wide” formatted data in this chapter, as well as how to change the shape of our data.\n\n7.2.1 Inspecting data\nLike in the previous exercise, we can use the head() and summary() functions to view aspects of the dataframe. We can also use the view() function to open the entire file in the R Studio Viewer, however view large files (millions of rows) can cause R Studio to crash. We can also install additional packages, such as skimr to get an even more detailed summary (run install.package(\"skimr\") in your console).\n\nhead(case_data)\nstr(case_data)\nsummary(case_data)\n\n# Using skimr package, remember to install first!\nlibrary(skimr)\nskim(case_data)\n\n\n\n\nQuestion 1: How many rows and columns are in case_data?\n\n\nQuestion 2: What “type” of data are each column (character, vector, etc.)?"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#data-manipulation-using-tidyverse",
    "href": "dpylr-tidyr-intro.html#data-manipulation-using-tidyverse",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "7.3 Data manipulation using *tidyverse*",
    "text": "7.3 Data manipulation using *tidyverse*\nIn Chapter 1 we learned some built-in functions, or “base” functions, for simple data manipulations such as selecting a specific column or filter for only rows that match some criteria. In this lesson we will learn the *tidyverse* approach to these and additional common data manipulation tasks, using two packages called *dplyr* and *tidyr*. The *dplyr* package provides functions for the most common data manipulations jobs, and the *tidyr*package provides functions for reshaping or pivoting dataframes (similar to pivot tables in Microsoft Excel).\n\n7.3.1 Selecting columns and filtering rows\nTo select a specific column from a dataframe, use the select() functions. The first argument will always be the dataframe object that you’re working with, followed by the name(s) of the column or columns you want to select.\n\n# Select just one column (province)\nselect(case_data, province)\n# Select multiple columns\nselect(case_data, district, data_type, count)\n\nTo select all the columns except certain ones, you can use a - in front of the column name.\n\n# Select all but one column\nselect(case_data, -province)\n# Removing multiple columns\nselect(case_data, -period, -province)\n\nTo choose specific rows based on some criteria, use filter(). Again, the first argument will be the dataframe, then the following argument will be the condition that we want use to subset the data.\n\nfilter(case_data, province == \"Eastern\")\n\n# A tibble: 2,294 × 5\n# Rowwise: \n   period     province district   data_type count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt;\n 1 2018-01-01 Eastern  Chadiza    Clinical     89\n 2 2018-01-01 Eastern  Chadiza    Confirmed  3926\n 3 2018-01-01 Eastern  Chadiza    Tested     8261\n 4 2018-01-01 Eastern  Chasefu    Clinical    357\n 5 2018-01-01 Eastern  Chasefu    Confirmed  2599\n 6 2018-01-01 Eastern  Chasefu    Tested     9021\n 7 2018-01-01 Eastern  Chipangali Confirmed  6330\n 8 2018-01-01 Eastern  Chipangali Tested    21612\n 9 2018-01-01 Eastern  Chipata    Clinical    417\n10 2018-01-01 Eastern  Chipata    Confirmed  4079\n# ℹ 2,284 more rows\n\n\nNotice here that just like in Chapter 1 use have to use a == sign for setting a condition. You read this as saying, “choose the rows in case_data where province is equal to”Eastern”. Also notice that the number of rows in the object has gone down from 18172 to 2294.\nWe can filter on multiple conditions at once using multiple arguments, using a , to state separate conditions.\n\nfilter(case_data, province == \"Eastern\", data_type == \"Clinical\")\n\n# A tibble: 379 × 5\n# Rowwise: \n   period     province district   data_type count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt;\n 1 2018-01-01 Eastern  Chadiza    Clinical     89\n 2 2018-01-01 Eastern  Chasefu    Clinical    357\n 3 2018-01-01 Eastern  Chipata    Clinical    417\n 4 2018-01-01 Eastern  Kasenengwa Clinical    331\n 5 2018-01-01 Eastern  Katete     Clinical     28\n 6 2018-01-01 Eastern  Lumezi     Clinical     19\n 7 2018-01-01 Eastern  Lundazi    Clinical     38\n 8 2018-01-01 Eastern  Lusangazi  Clinical     58\n 9 2018-01-01 Eastern  Petauke    Clinical     20\n10 2018-01-01 Eastern  Sinda      Clinical      1\n# ℹ 369 more rows\n\n\nBy default, each of the conditions in filter() must be TRUE to remain in the subset, however there are special operators that allow for more complex conditional operations. The most common are the AND (&) and OR (|) operators. Here are some examples:\n\n# Province is Easter AND data type is Clinical \nfilter(case_data, province == \"Eastern\" & data_type == \"Clinical\")\n\n# Province is Eastern OR data type is Clinical \nfilter(case_data, province == \"Eastern\" | data_type == \"Clinical\")\n\n# Province is Central OR Eastern, AND count is over 1,000\nfilter(case_data, province == \"Central\" | province == \"Eastern\", count &gt; 1000)\n\n\n\nQuestion 3: Why did we not use & in the third example?\n\nAnother useful operator is the MATCH operator (%in%), which will return TRUE if a value matches any value in a list of possible options.\n\n# Keep rows where data type could be Clinical, Confirmed, or Tested\nfilter(case_data, data_type %in% c(\"Clinical\", \"Confirmed\", \"Tested\"))\n\n# A tibble: 13,062 × 5\n# Rowwise: \n   period     province district     data_type count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;     &lt;dbl&gt;\n 1 2018-01-01 Central  Chibombo     Clinical     26\n 2 2018-01-01 Central  Chibombo     Confirmed  1897\n 3 2018-01-01 Central  Chibombo     Tested     8215\n 4 2018-01-01 Central  Chisamba     Confirmed  2192\n 5 2018-01-01 Central  Chisamba     Tested     7772\n 6 2018-01-01 Central  Chitambo     Clinical     33\n 7 2018-01-01 Central  Chitambo     Confirmed  6011\n 8 2018-01-01 Central  Chitambo     Tested     3993\n 9 2018-01-01 Central  Itezhi-tezhi Confirmed   890\n10 2018-01-01 Central  Itezhi-tezhi Tested     5007\n# ℹ 13,052 more rows\n\n# Keep rows from a group of selected districts\nstudy_districts &lt;- c(\"Chadiza\", \"Chipata\", \"Katete\", \"Lumezi\")\nfilter(case_data, district %in% study_districts)\n\n# A tibble: 649 × 5\n# Rowwise: \n   period     province district data_type count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt;\n 1 2018-01-01 Eastern  Chadiza  Clinical     89\n 2 2018-01-01 Eastern  Chadiza  Confirmed  3926\n 3 2018-01-01 Eastern  Chadiza  Tested     8261\n 4 2018-01-01 Eastern  Chipata  Clinical    417\n 5 2018-01-01 Eastern  Chipata  Confirmed  4079\n 6 2018-01-01 Eastern  Chipata  Tested    20550\n 7 2018-01-01 Eastern  Katete   Clinical     28\n 8 2018-01-01 Eastern  Katete   Confirmed  3124\n 9 2018-01-01 Eastern  Katete   Tested    18207\n10 2018-01-01 Eastern  Lumezi   Clinical     19\n# ℹ 639 more rows\n\n\n\nQuestion 4: Can you show all of the “Tested” data in Western Province?\n\n\nQuestion 5: Can you show all “Confirmed” that have a count over 2000?\n\nFinally, the ! operator in R used for NOT or opposite conditions. The most common use cases are for using NOT EQUAL (!=) or does NOT MATCH operations.\n\n# Keep all rows where province is NOT Lusaka\nfilter(case_data, province != \"Lusaka\")\n\n# A tibble: 16,993 × 5\n# Rowwise: \n   period     province district     data_type             count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;                 &lt;dbl&gt;\n 1 2018-01-01 Central  Chibombo     Clinical                 26\n 2 2018-01-01 Central  Chibombo     Confirmed              1897\n 3 2018-01-01 Central  Chibombo     Tested                 8215\n 4 2018-01-01 Central  Chisamba     Confirmed              2192\n 5 2018-01-01 Central  Chisamba     Tested                 7772\n 6 2018-01-01 Central  Chitambo     Clinical                 33\n 7 2018-01-01 Central  Chitambo     Confirmed              6011\n 8 2018-01-01 Central  Chitambo     Tested                 3993\n 9 2018-01-01 Central  Itezhi-tezhi Confirmed               890\n10 2018-01-01 Central  Itezhi-tezhi Confirmed_Passive_CHW   897\n# ℹ 16,983 more rows\n\n# Keep rows where data type does NOT match Clinical, Confirmed, or Tested\nfilter(case_data, !data_type %in% c(\"Clinical\", \"Confirmed\", \"Tested\"))\n\n# A tibble: 5,110 × 5\n# Rowwise: \n   period     province district     data_type             count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;                 &lt;dbl&gt;\n 1 2018-01-01 Central  Itezhi-tezhi Confirmed_Passive_CHW   897\n 2 2018-01-01 Central  Itezhi-tezhi Tested_Passive_CHW     2708\n 3 2018-01-01 Central  Mumbwa       Confirmed_Passive_CHW   861\n 4 2018-01-01 Central  Mumbwa       Tested_Passive_CHW     3173\n 5 2018-01-01 Central  Shibuyunji   Confirmed_Passive_CHW     6\n 6 2018-01-01 Central  Shibuyunji   Tested_Passive_CHW       94\n 7 2018-01-01 Eastern  Petauke      Confirmed_Passive_CHW     0\n 8 2018-01-01 Eastern  Petauke      Tested_Passive_CHW        0\n 9 2018-01-01 Lusaka   Chirundu     Confirmed_Passive_CHW    55\n10 2018-01-01 Lusaka   Chirundu     Tested_Passive_CHW      406\n# ℹ 5,100 more rows\n\n\nNote that for NOT EQUAL the ! operator comes right next to the = sign, but for the NOT MATCH condition the ! comes before the condition state. In the second case you can read that as, “do the opposite of this condition”.\n\nQuestion 6a: Create a table for all malaria tests (health facility and CHW) in Western and Southern Province in 2020.\n\n\nQuestion 6b: Create a table for all malaria tests (health facility and CHW) NOT in Western and Southern Province in 2020.\n\n\nQuestion 7a: Create a table for all clinical and confirmed cases that are over 500.\n\n\nQuestion 7b: Create a table for all data that are NOT clinical and confirmed cases that are over 500.\n\nThe types of conditional states that you can use depends on the type of column you want to base your filter()on. For example, filter(case_data, count &gt; 1000) makes sense since the count column contains numeric data. However, filter(case_data, province &gt; 1000) doesn’t make sense since the province column contains character data. The rule of thumb is that the value you use to set your condition should match the “type” of data in selected column.\nIn the next section, we see how to deal with a special case:\n\n\n7.3.2 Working with dates using the *lubridate* package\nIn the “tidy” data approach to working with data each column is a specific type of data, each row is an observation, and each cell is an individual value which conveys a single piece of information. Our dataset matches this philosophy, except for the “period” values, which contain information on the year, month, and day of the observation.\nWe could create separate columns for the year, month, and day, but this may complicate our filtering. For instance, what happens if we want to filter for a study period that continues across over parts of adjacent months or year? Such a common task would require complex set of conditional statements to filter correctly.\nThe *lubridate* package provides a number of functions to make working with data much easier. This is not included in *tidyverse*, so we have to install and then load it into our session.\n\n# install.packages(lubridate)\nlibrary(lubridate)\n\nThe ymd() function allows us to create a Date class object based on the string input for YEAR-MONTH-DAY:\n\n# Vector of workshop days\nworkshop_days &lt;- c(\"2021-11-15\", \"2021-11-16\", \"2021-11-17\", \"2021-11-18\",\"2021-11-19\")\nclass(workshop_days)\n\n[1] \"character\"\n\n# Convert to a Date class\nworkshop_days &lt;- ymd(workshop_days)\nclass(workshop_days)\n\n[1] \"Date\"\n\n\nOnce you have a Date class object, *lubridate* provides many, many functions for working with date information. The primary functions we will use in this workshop are year() and month(), but there are many more in this *lubridate* cheatsheet.\n\nyear(workshop_days)\n\n[1] 2021 2021 2021 2021 2021\n\nmonth(workshop_days)\n\n[1] 11 11 11 11 11\n\nmonth(workshop_days, label = TRUE)\n\n[1] Nov Nov Nov Nov Nov\n12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec\n\n\nThese functions can be used in filter().\n\nfilter(case_data, year(period) == 2020)\n\n# A tibble: 5,232 × 5\n# Rowwise: \n   period     province district     data_type             count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;                 &lt;dbl&gt;\n 1 2020-01-01 Central  Chibombo     Clinical                 51\n 2 2020-01-01 Central  Chibombo     Confirmed              9473\n 3 2020-01-01 Central  Chibombo     Tested                17192\n 4 2020-01-01 Central  Chisamba     Confirmed              2885\n 5 2020-01-01 Central  Chisamba     Tested                 5499\n 6 2020-01-01 Central  Chitambo     Clinical               1895\n 7 2020-01-01 Central  Chitambo     Confirmed              9929\n 8 2020-01-01 Central  Chitambo     Tested                12642\n 9 2020-01-01 Central  Itezhi-tezhi Confirmed              1406\n10 2020-01-01 Central  Itezhi-tezhi Confirmed_Passive_CHW  1184\n# ℹ 5,222 more rows\n\nfilter(case_data, between(period, ymd(\"2019-01-01\"), ymd(\"2019-06-30\")))\n\n# A tibble: 2,394 × 5\n# Rowwise: \n   period     province district     data_type count\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;     &lt;dbl&gt;\n 1 2019-01-01 Central  Chibombo     Clinical    347\n 2 2019-01-01 Central  Chibombo     Confirmed  3706\n 3 2019-01-01 Central  Chibombo     Tested     8116\n 4 2019-01-01 Central  Chisamba     Confirmed  2304\n 5 2019-01-01 Central  Chisamba     Tested     6975\n 6 2019-01-01 Central  Chitambo     Clinical      2\n 7 2019-01-01 Central  Chitambo     Confirmed  7328\n 8 2019-01-01 Central  Chitambo     Tested     8320\n 9 2019-01-01 Central  Itezhi-tezhi Clinical      6\n10 2019-01-01 Central  Itezhi-tezhi Confirmed   833\n# ℹ 2,384 more rows\n\n\n\n\n\n\n\nQuestion 8: What were the reported total tests (HF and CHW) in Chadiza district each month during 2018?\n\n\nQuestion 9: How many tests (HF and CHW) were conducted in April 2020 in Nchelenge district?\n\n\nQuestion 10 (HARD): What were the monthly confirmed cases in Chadiza during the peak transmission season (December to May) each year?\n\n\n\n7.3.3 Creating new columns with mutate()\nAnother common task is creating new columns based on values in existing columns. The *dplyr* function for this action is mutate().\nHere is an example using the *lubridate* function from the section above to make a column for the year of observation:\n\nmutate(case_data, year = year(period))\n\n# A tibble: 18,172 × 6\n# Rowwise: \n   period     province district     data_type             count  year\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt;\n 1 2018-01-01 Central  Chibombo     Clinical                 26  2018\n 2 2018-01-01 Central  Chibombo     Confirmed              1897  2018\n 3 2018-01-01 Central  Chibombo     Tested                 8215  2018\n 4 2018-01-01 Central  Chisamba     Confirmed              2192  2018\n 5 2018-01-01 Central  Chisamba     Tested                 7772  2018\n 6 2018-01-01 Central  Chitambo     Clinical                 33  2018\n 7 2018-01-01 Central  Chitambo     Confirmed              6011  2018\n 8 2018-01-01 Central  Chitambo     Tested                 3993  2018\n 9 2018-01-01 Central  Itezhi-tezhi Confirmed               890  2018\n10 2018-01-01 Central  Itezhi-tezhi Confirmed_Passive_CHW   897  2018\n# ℹ 18,162 more rows\n\n\nFirst, state the name for the new column, then = followed by the function for the new value. You can create multiple new columns in a single mutate() call, using a , to separate each column.\n\nmutate(case_data,\n    year = year(period), \n    month_num = month(period),\n    month_name = month(period, label = TRUE))\n\n# A tibble: 18,172 × 8\n# Rowwise: \n   period     province district     data_type   count  year month_num month_name\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;ord&gt;     \n 1 2018-01-01 Central  Chibombo     Clinical       26  2018         1 Jan       \n 2 2018-01-01 Central  Chibombo     Confirmed    1897  2018         1 Jan       \n 3 2018-01-01 Central  Chibombo     Tested       8215  2018         1 Jan       \n 4 2018-01-01 Central  Chisamba     Confirmed    2192  2018         1 Jan       \n 5 2018-01-01 Central  Chisamba     Tested       7772  2018         1 Jan       \n 6 2018-01-01 Central  Chitambo     Clinical       33  2018         1 Jan       \n 7 2018-01-01 Central  Chitambo     Confirmed    6011  2018         1 Jan       \n 8 2018-01-01 Central  Chitambo     Tested       3993  2018         1 Jan       \n 9 2018-01-01 Central  Itezhi-tezhi Confirmed     890  2018         1 Jan       \n10 2018-01-01 Central  Itezhi-tezhi Confirmed_…   897  2018         1 Jan       \n# ℹ 18,162 more rows\n\n\nRemember that if you want to save any changes you will have to save the output into an object using the &lt;- assignment operator.\n\ncase_data_dates &lt;- mutate(case_data,\n    year = year(period), \n    month_num = month(period),\n    month_name = month(period, label = TRUE))\n\nIn later sections we will see how to use mutate() to make calculations.\n\nQuestion 11: Can you add a new variable (column) to the dataset that gives the quarter of the year?\n\n\nQuestion 12: Can you add a new variable (column) to the dataset that gives just the last 2 digits of the year? i.e. 2021 becomes 21"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#use-pipes-to-combine-steps",
    "href": "dpylr-tidyr-intro.html#use-pipes-to-combine-steps",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "7.4 Use Pipes to combine steps",
    "text": "7.4 Use Pipes to combine steps\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nFor intermediate steps, we need to create a new intermediate object for the output of our first function, which will then be used as an input for the second function:\n\ncase_data_lusaka_confirmed &lt;- filter(case_data, province == \"Lusaka\", data_type == \"Confirmed\")\ncase_data_lusaka_district_months &lt;- select(case_data_lusaka_confirmed, district, period, count)\ncase_data_lusaka_district_months\n\n# A tibble: 301 × 3\n# Rowwise: \n   district period     count\n   &lt;chr&gt;    &lt;date&gt;     &lt;dbl&gt;\n 1 Chilanga 2018-01-01   151\n 2 Chirundu 2018-01-01   198\n 3 Chongwe  2018-01-01   426\n 4 Kafue    2018-01-01   290\n 5 Luangwa  2018-01-01   776\n 6 Lusaka   2018-01-01  1248\n 7 Rufunsa  2018-01-01  2907\n 8 Chilanga 2018-02-01   165\n 9 Chirundu 2018-02-01    89\n10 Chongwe  2018-02-01   467\n# ℹ 291 more rows\n\n\nThis approach is readable, but it can quickly clutter up your workspace and take up additional memory. And if you’re trying to use meaningful object names it can get tedious quickly.\nYou can also nest the functions (one function inside of the another).\n\ncase_data_lusaka_district_months &lt;- select(\n  filter(case_data, province == \"Lusaka\", data_type == \"Confirmed\"), \n  district, period, count)\n\nThis doesn’t clutter the workshop or take up unnecessary memory, but it is difficult to read especially since R will interpret these steps from the inside out (first filter, then select).\nThe last option is to use pipes, a new addition to R. A pipe lets you take the output from one function and input it directly into the next function. By default, this will automatically go into the first argument of the new function. This is useful for stringing together multiple data cleaning steps while maintaining readability and keeping our environment clear. The *tidyverse* package includes a pipe function which looks like %&gt;%. In RStudio, the shortcut for this pipe is Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac. You can adjust this shortcut under Tools &gt;&gt; Modify Keyboard Shortcuts…\nHere’s an example of using a pipe for combine the filter and select from the previous example.\n\ncase_data %&gt;% \n  filter(province == \"Lusaka\", data_type == \"Confirmed\") %&gt;% \n  select(district, period, count)\n\n# A tibble: 301 × 3\n# Rowwise: \n   district period     count\n   &lt;chr&gt;    &lt;date&gt;     &lt;dbl&gt;\n 1 Chilanga 2018-01-01   151\n 2 Chirundu 2018-01-01   198\n 3 Chongwe  2018-01-01   426\n 4 Kafue    2018-01-01   290\n 5 Luangwa  2018-01-01   776\n 6 Lusaka   2018-01-01  1248\n 7 Rufunsa  2018-01-01  2907\n 8 Chilanga 2018-02-01   165\n 9 Chirundu 2018-02-01    89\n10 Chongwe  2018-02-01   467\n# ℹ 291 more rows\n\n\nIn this code, we used a pipe to send case_data into a filter() function and keep the rows for confirmed cases in Lusaka province, then used another pipe to send that output into a select() where we only kept the district, period, and count columns. We didn’t need to explicitly state the data object in the filter and select because data is always the first argument.\nYou may find it helpful to read the pipe like the word “then”. Take the case, then filter for Lusaka province and confirmed cases, then select the districts, periods, and counts. We can also save this into a new object.\n\nlusaka_confirmed_cases &lt;- case_data %&gt;% \n  filter(province == \"Lusaka\", data_type == \"Confirmed\") %&gt;% \n  select(district, period, count)\n\n\n\n\n\nQuestion 13: Using pipes, create a table contain the confirmed cases in January 2019 for each district in Southern Province. The table should only have two columns (district and counts)\n\n\n7.4.1 Grouping and summarizing data\nAnother common data manipulation tasks involve grouping data together and applying summary functions such as calculating means or totals. We can do some of these types of operations already. For instance, we can get the total number of clinical cases in Lusaka Province.\n\nlusaka_clinical &lt;- case_data %&gt;% \n  filter(data_type == \"Clinical\", province == \"Lusaka\")\nsum(lusaka_clinical$count, na.rm = T)\n\n[1] 68524\n\n\nBut what if we want to get summaries for each province at once? We could repeat the steps above, separating each province, calculating the totals, and then grouping these summaries back together. In programming this concept is often referred to as the split-apply-combine paradigm. The key *dplyr* functions for these tasks are group_by() and summarize() (you can also use the “proper” summarise() spelling as well).\nFirst, group_by() takes in a column that contains categorical data, then use summarize() to calculate new summary statistics.\n\ncase_data %&gt;% \n  filter(data_type == \"Tested\") %&gt;% \n  group_by(province) %&gt;% \n  summarise(mean_tested = mean(count, na.rm = TRUE))\n\n# A tibble: 11 × 2\n   province     mean_tested\n   &lt;chr&gt;              &lt;dbl&gt;\n 1 Central            8199.\n 2 Copperbelt        15741.\n 3 Eastern           12389.\n 4 Luapula            9217.\n 5 Lusaka             5646.\n 6 Muchinga           8709.\n 7 Northern           7090.\n 8 Northwestern      10500.\n 9 Southern           1987.\n10 Western            5524.\n11 &lt;NA&gt;               1234.\n\n\nYou can also group by more than one column, and output multiple columns within a single summarize() call.\n\ncase_data %&gt;% \n  filter(data_type == \"Tested\") %&gt;% \n  group_by(province, district, year(period)) %&gt;% \n  summarise(mean_tested_per_month = mean(count, na.rm = TRUE), \n            total_tested_per_month = sum(count, na.rm = TRUE))\n\n# A tibble: 466 × 5\n# Groups:   province, district [117]\n   province district `year(period)` mean_tested_per_month total_tested_per_month\n   &lt;chr&gt;    &lt;chr&gt;             &lt;dbl&gt;                 &lt;dbl&gt;                  &lt;dbl&gt;\n 1 Central  Chibombo           2018                 8442.                 101301\n 2 Central  Chibombo           2019                 7309.                  87711\n 3 Central  Chibombo           2020                12910.                 154926\n 4 Central  Chibombo           2021                14252.                  99763\n 5 Central  Chisamba           2018                 6959.                  83511\n 6 Central  Chisamba           2019                 5204                   62448\n 7 Central  Chisamba           2020                 5815.                  69776\n 8 Central  Chisamba           2021                 5825.                  40773\n 9 Central  Chitambo           2018                 4071.                  48855\n10 Central  Chitambo           2019                 5620.                  67442\n# ℹ 456 more rows\n\n\n\ncase_data %&gt;% \n  filter(data_type == \"Tested\") %&gt;% \n  group_by(province, district, year(period)) %&gt;% \n  summarise(mean_tested_per_month = mean(count, na.rm = TRUE), \n            total_tested_per_month = sum(count, na.rm = TRUE))\n\n# A tibble: 466 × 5\n# Groups:   province, district [117]\n   province district `year(period)` mean_tested_per_month total_tested_per_month\n   &lt;chr&gt;    &lt;chr&gt;             &lt;dbl&gt;                 &lt;dbl&gt;                  &lt;dbl&gt;\n 1 Central  Chibombo           2018                 8442.                 101301\n 2 Central  Chibombo           2019                 7309.                  87711\n 3 Central  Chibombo           2020                12910.                 154926\n 4 Central  Chibombo           2021                14252.                  99763\n 5 Central  Chisamba           2018                 6959.                  83511\n 6 Central  Chisamba           2019                 5204                   62448\n 7 Central  Chisamba           2020                 5815.                  69776\n 8 Central  Chisamba           2021                 5825.                  40773\n 9 Central  Chitambo           2018                 4071.                  48855\n10 Central  Chitambo           2019                 5620.                  67442\n# ℹ 456 more rows\n\n\nSometimes it is useful to rearrange the result of our summarized dataset, in which case we can use the arrange() function.\n\ncase_data %&gt;% \n  filter(data_type == \"Tested\", \n         year(period) == 2019) %&gt;% \n  group_by(district, period) %&gt;% \n  summarise(total_tested_per_month = sum(count)) %&gt;% \n  arrange(total_tested_per_month)\n\n# A tibble: 1,396 × 3\n# Groups:   district [117]\n   district   period     total_tested_per_month\n   &lt;chr&gt;      &lt;date&gt;                      &lt;dbl&gt;\n 1 Mwandi     2019-10-01                     45\n 2 Mwandi     2019-11-01                    144\n 3 Mwandi     2019-01-01                    267\n 4 Mwandi     2019-09-01                    287\n 5 Mwandi     2019-12-01                    292\n 6 Shang'ombo 2019-11-01                    312\n 7 Pemba      2019-08-01                    319\n 8 Shang'ombo 2019-07-01                    348\n 9 Shang'ombo 2019-10-01                    369\n10 Mwandi     2019-06-01                    389\n# ℹ 1,386 more rows\n\n\nBy default arranging with be in ascending order, you can use desc() to make the output descending.\n\ncase_data %&gt;% \n  filter(data_type == \"Tested\", \n         year(period) == 2019) %&gt;% \n  group_by(district, period) %&gt;% \n  summarise(total_tested_per_month = sum(count)) %&gt;% \n  arrange(desc(total_tested_per_month))\n\n# A tibble: 1,396 × 3\n# Groups:   district [117]\n   district      period     total_tested_per_month\n   &lt;chr&gt;         &lt;date&gt;                      &lt;dbl&gt;\n 1 Kapiri-Mposhi 2019-03-01                  53173\n 2 Kapiri-Mposhi 2019-04-01                  45125\n 3 Petauke       2019-04-01                  44856\n 4 Kitwe         2019-01-01                  44378\n 5 Kapiri-Mposhi 2019-05-01                  40387\n 6 Ndola         2019-04-01                  39858\n 7 Kitwe         2019-02-01                  39630\n 8 Chipangali    2019-04-01                  39166\n 9 Solwezi       2019-12-01                  38709\n10 Kitwe         2019-03-01                  37622\n# ℹ 1,386 more rows\n\n\n\n\n\n\n\n\n\nQuestion 14: What were the total number of confirmed cases in each province in 2019?\n\n\nQuestion 15: What were the total number of cases (Clinical and Confirmed) in each month for all provinces for each year?\n\n\nQuestion 16 (HARD): What were the total number of cases (Clinical and Confirmed) in the peak (dec - may) and the low (june - nov) transmission seasons for each district in Southern Province during the 2019/2020 transmission season (i.e. Dec 2019 - Nov 2020)?"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#reshaping-data-with-tidyr",
    "href": "dpylr-tidyr-intro.html#reshaping-data-with-tidyr",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "7.5 Reshaping data with *tidyr*",
    "text": "7.5 Reshaping data with *tidyr*\nSo far we have covered a bunch of *dplyr* functions for manipulating data, most of which have changed the number of rows and/or columns in our dataframe. However, even though the columns, rows, and values have changed none of these have changed the “structure” of the dataframe. At the end of each function or piped function, the output always followed the conditions we discussed early:\n\nEach column should be a single variable with one data type.\nEach row should be a single observation.\nEach cell should be a single value contains one piece of information.\n\nThis is commonly referred to as “long” format data, and often this means that there are relatively more rows than columns. Typically it is best to work in “long” format data, especially in R, however there are instances when we may want to change the “shape” of our data into the “wide” format. In Microsoft Excel this would be called creating a Pivot Table.\nThe *tidyr* package provides functions for reshaping data, including creating “wide” format pivot tables. To illustrate, lets take a look at records for a single district at a single timepoint.\n\ncase_data %&gt;% \n  filter(district == \"Chadiza\", period == ymd(\"2020-01-01\"))\n\n# A tibble: 4 × 5\n# Rowwise: \n  period     province district data_type             count\n  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;                 &lt;dbl&gt;\n1 2020-01-01 Eastern  Chadiza  Confirmed              3986\n2 2020-01-01 Eastern  Chadiza  Confirmed_Passive_CHW  7321\n3 2020-01-01 Eastern  Chadiza  Tested                 8152\n4 2020-01-01 Eastern  Chadiza  Tested_Passive_CHW    12297\n\n\nThe resulting table has six rows, because there are six different types of records included. But what if we wanted to create a table where there is a separate column for each type of record? The pivot_wider() function will allow us to create this kind of “wide” format table. This function requires us to state the column which our column names will come from (names_from), and which column the values in the new columns will come from (values_from).\n\ncase_data %&gt;% \n  filter(district == \"Chadiza\", period == ymd(\"2020-01-01\")) %&gt;% \n  pivot_wider(names_from = data_type, values_from = count)\n\n# A tibble: 1 × 7\n  period     province district Confirmed Confirmed_Passive_CHW Tested\n  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;        &lt;dbl&gt;                 &lt;dbl&gt;  &lt;dbl&gt;\n1 2020-01-01 Eastern  Chadiza       3986                  7321   8152\n# ℹ 1 more variable: Tested_Passive_CHW &lt;dbl&gt;\n\n\nThe resulting output just has one row, but new columns for each of the types of records. This “wide” format is often useful for creating summary tables.\nThe opposite function is called pivot_longer(), which will take in a “wide” format table and output a “long” format table. For pivot_longer() we need to state the column name for the “key” which provides the label, the column names for the values, and which columns we want to pivot on. Here is how we can convert the above example from “wide” format to “long” format.\n\nwide_data &lt;- case_data %&gt;% \n  filter(district == \"Chadiza\", period == ymd(\"2020-01-01\")) %&gt;% \n  pivot_wider(names_from = data_type, values_from = count)\n\n\nwide_data %&gt;% \n  pivot_longer(\n    names_to = \"data_type\", values_to = \"count\", \n    cols = c(Confirmed, Confirmed_Passive_CHW, Tested, \n             Tested_Passive_CHW))\n\n# A tibble: 4 × 5\n  period     province district data_type             count\n  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;                 &lt;dbl&gt;\n1 2020-01-01 Eastern  Chadiza  Confirmed              3986\n2 2020-01-01 Eastern  Chadiza  Confirmed_Passive_CHW  7321\n3 2020-01-01 Eastern  Chadiza  Tested                 8152\n4 2020-01-01 Eastern  Chadiza  Tested_Passive_CHW    12297\n\n\n\n\n\n\nQuestion 17: Create a table that contains the total number of confirmed cases each year for each province, then pivot wider to make it so the rows are the year and there is a column for each province.\n\nThink of this as a multi-step process\n1. Filter for confirmed cases\n2. Work out which columns you are grouping by (i.e. what are we grouping over….think geography/time?)\n3. Look at the output so far - what do we now want to sum over for our table?\n4. Now we need to pivot wider - we want to make new columns - where do those names to come from (names_from)?, where will we find the values to populate the new cells (values_from)?\n\nQuestion 17b: Can you make this table longer again, where we now have 3 columns - year, province and count\n\n\nQuestion 18: Create a table that contains the total number of CHW tests for each district and each year in Luapula Province, now pivot wider to make each district its own column where year is now the row - start by writing out the steps 1 by 1 as above"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#final-exercises",
    "href": "dpylr-tidyr-intro.html#final-exercises",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "7.6 Final Exercises",
    "text": "7.6 Final Exercises\n\n\nFor each province, calculate the total number of tests conducted by CHWs each year and present as a wide dataframe, where each column is a year and each row is a province and finally, order the dataframe such that the province with the most tests in 2020 is at the top\n\n\n\n\nFor each district in Eastern Province, calculate the test positivity rate at health facilities and by CHWs in 2020 (Test positivity = confirmed cases / total tests)\n\n\nTips for Final Exercises 1. Start by filtering your data - what geographical region, year, and data types do we need?\n2. Now we need to pivot wider - how can we now have data_type as our column names?\n3. Now we need to group_by - what are we grouping by?\n4. Almost there!! Now we need to sum up some columns - how can we do this?\n5. Now to calculate TPR - let’s use the mutate function\n6. Now let’s use the ‘select’ function to retrieve the columns we want"
  },
  {
    "objectID": "dpylr-tidyr-intro.html#function-cheatsheet",
    "href": "dpylr-tidyr-intro.html#function-cheatsheet",
    "title": "6  Data manipulation with *dplyr* and *tidyr*",
    "section": "7.7 Function cheatsheet",
    "text": "7.7 Function cheatsheet\n\nMain cheat sheet page\n*dplyr* cheat sheet link\nlubridate cheat sheet\ntidyr cheat sheet\n\n*dplyr* functions\n\nselect(): subset columns\nfilter(): subset rows on condition\nmutate(): create new columns\ngroup_by(): group data by one or more column\nsummarise(): create summaries from dataframe (works within groups)\narrange(): reorder dataframe based on ascending order (use desc() to invert)\n\n*tidyr* functions\n\npivot_wider(): go from “long” to “wide” format\npivot_longer(): go from “wide” to “long” format\n\n*lubridate* functions\n\nymd(): convert class to date object based on “YYYY-MM-DD”\nyear(): return the year from a date input\nmonth(): return the month from a date input\nquarter(): return the year quarter (1,2,3,4) from a date input"
  },
  {
    "objectID": "joins.html",
    "href": "joins.html",
    "title": "6  Joining data in tidyverse",
    "section": "",
    "text": "Joining dataframes is a common task in data analysis, enabling you to combine datasets based on common keys. The dplyr package in the tidyverse provides several functions for different types of joins. This tutorial will focus on the left_join() function.\n\n6.0.1 Installing and Loading the tidyverse Package\nFirst, ensure that you have the tidyverse package installed and loaded.\nInstall the tidyverse package:\ninstall.packages(\"tidyverse\")\nLoad the tidyverse package:\nlibrary(tidyverse)\n\n\n6.0.2 Example Dataframes\nLet’s create two example dataframes for illustration.\nCreating Dataframe 1:\ndf1 &lt;- tibble(\n  id = c(1, 2, 3, 4),\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\")\n)\nprint(df1)\nOutput:\n# A tibble: 4 × 2\n     id name  \n  &lt;dbl&gt; &lt;chr&gt; \n1     1 Alice \n2     2 Bob   \n3     3 Charlie\n4     4 David\nCreating Dataframe 2:\ndf2 &lt;- tibble(\n  id = c(1, 2, 4, 5),\n  score = c(85, 90, 88, 92)\n)\nprint(df2)\nOutput:\n# A tibble: 4 × 2\n     id score\n  &lt;dbl&gt; &lt;dbl&gt;\n1     1    85\n2     2    90\n3     4    88\n4     5    92\n\n\n6.0.3 Using left_join()\nThe left_join() function combines rows from df1 with matching rows from df2. If there is no match, the result will contain NA for the columns from df2.\nSyntax:\nleft_join(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"), ...)\n\nx: The left dataframe.\ny: The right dataframe.\nby: A character vector of variables to join by. If NULL, defaults to all variables with common names in x and y.\n\nExample:\njoined_df &lt;- left_join(df1, df2, by = \"id\")\nprint(joined_df)\nOutput:\n# A tibble: 4 × 3\n     id name    score\n  &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n1     1 Alice      85\n2     2 Bob        90\n3     3 Charlie    NA\n4     4 David      88\n\n\n6.0.4 Handling Different Column Names\nIf the key columns have different names in the dataframes, use the by argument to specify the columns to join by.\nExample with Different Column Names:\ndf3 &lt;- tibble(\n  student_id = c(1, 2, 4, 5),\n  grade = c(\"A\", \"B\", \"B+\", \"A-\")\n)\n\njoined_df2 &lt;- left_join(df1, df3, by = c(\"id\" = \"student_id\"))\nprint(joined_df2)\nOutput:\n# A tibble: 4 × 3\n     id name    grade\n  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;\n1     1 Alice   A    \n2     2 Bob     B    \n3     3 Charlie NA   \n4     4 David   B+\n\n\n6.0.5 Conclusion\nUsing the left_join() function from the dplyr package in the tidyverse, you can easily join dataframes based on common keys. This is useful for combining related datasets and performing comprehensive data analysis. By understanding the basics of joins, you can leverage the power of dplyr to handle more complex data manipulations."
  }
]